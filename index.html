<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Preflop Trainer (Browser) – vNext</title>
  <style>
    :root{
      --bg:#0b0f14;
      --panel:#101824;
      --panel2:#0f1621;
      --text:#e6eef8;
      --muted:#9fb2c7;
      --line:#1d2a3b;
      --accent:#6aa6ff;

      /* GTO-ish colors */
      --fold:#2e6ea6;
      --call:#54b96b;
      --raise:#ff3b3b;
      --raise2:#c62828;
      --jam:#4b0f14;

      --warn:#ffcc66;
      --good:#5ce38a;
      --bad:#ff5c6a;

      --radius:14px;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:var(--sans);
      background: radial-gradient(1200px 800px at 20% -10%, #172234 0%, var(--bg) 55%) fixed;
      color:var(--text);
      height:100vh;
      overflow:hidden;
    }
    button, input, select{font-family:inherit}
    .topbar{
      height:56px;
      display:flex;
      align-items:center;
      gap:12px;
      padding:10px 14px;
      border-bottom:1px solid var(--line);
      background:rgba(9,13,19,.7);
      backdrop-filter: blur(10px);
    }
    .brand{
      display:flex;
      align-items:center;
      gap:10px;
      min-width:220px;
    }
    .dot{
      width:12px;height:12px;border-radius:50%;
      background:linear-gradient(145deg, #6aa6ff, #a06bff);
      box-shadow: 0 0 0 5px rgba(106,166,255,.12);
    }
    .brand strong{letter-spacing:.3px}
    .spacer{flex:1}
    .seg{
      display:inline-flex;
      border:1px solid var(--line);
      border-radius:999px;
      overflow:hidden;
      background:rgba(16,24,36,.8);
    }
    .seg button{
      border:0;
      background:transparent;
      padding:8px 12px;
      color:var(--muted);
      cursor:pointer;
      font-size:13px;
    }
    .seg button.active{
      background:rgba(106,166,255,.18);
      color:var(--text);
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      border:1px solid var(--line);
      background:rgba(16,24,36,.8);
      padding:6px 10px;
      border-radius:999px;
      color:var(--muted);
      font-size:13px;
      white-space:nowrap;
    }
    .pill b{color:var(--text); font-weight:700}
    .btn{
      border:1px solid var(--line);
      background:rgba(16,24,36,.8);
      color:var(--text);
      padding:8px 12px;
      border-radius:12px;
      cursor:pointer;
      transition:transform .05s ease, background .15s ease;
    }
    .btn:hover{background:rgba(22,34,51,.9)}
    .btn:active{transform:translateY(1px)}
    .btn.primary{
      border-color:rgba(106,166,255,.35);
      background:rgba(106,166,255,.18);
    }
    .btn.danger{
      border-color:rgba(255,92,106,.35);
      background:rgba(255,92,106,.12);
    }
    .btn.small{padding:6px 10px; border-radius:10px; font-size:13px}
    .btn:disabled{opacity:.5; cursor:not-allowed}

    .iconBtn{
      width:30px;height:30px;
      display:inline-flex;align-items:center;justify-content:center;
      border:1px solid var(--line);
      background:rgba(16,24,36,.65);
      border-radius:10px;
      cursor:pointer;
      color:var(--muted);
      padding:0;
    }
    .iconBtn:hover{filter:brightness(1.1); color:var(--text)}
    .iconBtn:active{transform:translateY(1px)}
    .iconBtn.primary{border-color:rgba(106,166,255,.35); background:rgba(106,166,255,.14)}
    .iconBtn.danger{border-color:rgba(255,92,106,.35); background:rgba(255,92,106,.10)}

    .main{
      height:calc(100vh - 56px);
      display:flex;
      overflow:hidden;
    }
    .left{
      width:360px;
      min-width:280px;
      max-width:560px;
      border-right:1px solid var(--line);
      background:rgba(12,18,27,.68);
      backdrop-filter: blur(10px);
      display:flex;
      flex-direction:column;
      overflow:hidden;
    }
    .divider{
      width:6px;
      cursor:col-resize;
      background:transparent;
    }
    .right{
      flex:1;
      display:flex;
      flex-direction:column;
      overflow:hidden;
      padding:14px;
      gap:14px;
    }
    .panel{
      border:1px solid var(--line);
      background:rgba(16,24,36,.75);
      border-radius:var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .panelHeader{
      padding:12px 12px 10px;
      border-bottom:1px solid var(--line);
      display:flex;
      align-items:center;
      gap:10px;
    }
    .panelHeader h3{
      margin:0;
      font-size:14px;
      letter-spacing:.2px;
    }
    .panelBody{padding:12px}
    .muted{color:var(--muted)}
    .tiny{font-size:12px}
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    .col{display:flex; flex-direction:column; gap:8px}
    .hr{height:1px;background:var(--line);margin:10px 0}
    .mono{font-family:var(--mono)}

    .badge{
      padding:5px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      font-size:12px;
      color:var(--muted);
      background:rgba(0,0,0,.18);
    }
    .badge.good{color:var(--good); border-color: rgba(92,227,138,.25); background:rgba(92,227,138,.08)}
    .badge.bad{color:var(--bad); border-color: rgba(255,92,106,.25); background:rgba(255,92,106,.08)}
    .badge.warn{color:var(--warn); border-color: rgba(255,204,102,.25); background:rgba(255,204,102,.08)}
    .tag{
      display:inline-flex;
      gap:6px;
      align-items:center;
      border:1px solid var(--line);
      padding:4px 8px;
      border-radius:999px;
      background:rgba(0,0,0,.18);
      color:var(--muted);
      font-size:12px;
    }
    .sw{width:10px;height:10px;border-radius:3px; display:inline-block; margin-right:6px; vertical-align:middle}

    /* Scenario list */
    .list{
      display:flex;
      flex-direction:column;
      gap:8px;
      max-height:360px;
      overflow:auto;
      padding-right:6px;
    }
    .item{
      border:1px solid var(--line);
      background:rgba(15,22,33,.75);
      border-radius:12px;
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .itemTop{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
    }
    .itemTitle{
      font-size:13px;
      color:var(--text);
      line-height:1.25;
      word-break:break-word;
      cursor:pointer;
    }
    .itemTitle:hover{ text-decoration: underline; }
    .itemMeta{
      display:flex; gap:6px; flex-wrap:wrap;
      color:var(--muted);
      font-size:12px;
    }

    /* Compact trainer list */
    .itemCompact{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .itemLeft{
      display:flex; gap:10px; align-items:flex-start; flex:1; min-width:0;
    }
    .itemName{
      font-size:13px; color:var(--text); line-height:1.25;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
      cursor:pointer;
    }
    .itemName:hover{ text-decoration: underline; }
    .itemIcons{display:flex; gap:6px; align-items:center; flex:0 0 auto;}

    /* Cards */
    .scenarioName{
      font-size:16px;
      font-weight:900;
      letter-spacing:.2px;
      margin-top:2px;
      margin-bottom:4px;
      color:var(--text);
      text-shadow:0 1px 1px rgba(0,0,0,.4);
    }
    .cards{
      display:flex; gap:10px; align-items:center;
    }
    .card{
      width:56px; height:78px;
      border-radius:12px;
      background:linear-gradient(180deg, #ffffff 0%, #e8eef7 100%);
      color:#111;
      position:relative;
      box-shadow: 0 10px 20px rgba(0,0,0,.35);
      border:1px solid rgba(0,0,0,.15);
      user-select:none;
    }
    .card .r{
      position:absolute; top:8px; left:8px;
      font-size:18px; font-weight:900;
      font-family: var(--mono);
    }
    .card .s{
      position:absolute; top:30px; left:9px;
      font-size:18px;
    }
    .card .mid{
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      font-size:28px;
      opacity:.9;
    }
    .redSuit{color:#c5162e}
    .blackSuit{color:#111}

    .rngBanner{
      margin-top:8px;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(255,204,102,.35);
      background:rgba(255,204,102,.08);
      text-align:center;
      font-weight:900;
      letter-spacing:.6px;
      color:var(--warn);
      font-size:22px;
      font-family:var(--mono);
      text-shadow:0 1px 1px rgba(0,0,0,.35);
      user-select:none;
    }

    /* Poker action buttons */
    .actionBar{
      display:flex;
      gap:10px;
      align-items:stretch;
      flex-wrap:wrap;
    }
    .actBtn{
      border:1px solid var(--line);
      background:rgba(15,22,33,.75);
      color:var(--text);
      padding:12px 14px;
      border-radius:14px;
      cursor:pointer;
      min-width:130px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      transition:transform .05s ease, filter .15s ease;
      user-select:none;
    }
    .actBtn:hover{filter:brightness(1.06)}
    .actBtn:active{transform:translateY(1px)}
    .k{
      font-size:12px;
      color:var(--muted);
      border:1px solid var(--line);
      padding:3px 8px;
      border-radius:999px;
      background:rgba(0,0,0,.22);
      font-family:var(--mono);
    }
    .actFold{background:rgba(46,110,166,.20); border-color:rgba(46,110,166,.35)}
    .actCall{background:rgba(84,185,107,.18); border-color:rgba(84,185,107,.35)}
    .actRaise{background:rgba(255,59,59,.14); border-color:rgba(255,59,59,.35)}
    .actJam{background:rgba(75,15,20,.40); border-color:rgba(170,40,55,.35)}

    /* Grid */
    .gridWrap{
      display:flex;
      flex-direction:column;
      gap:10px;
      height:100%;
      overflow:hidden;
    }
    .grid{
      --cell: 44px;
      display:grid;
      grid-template-columns: repeat(13, var(--cell));
      grid-auto-rows: var(--cell);
      gap:2px;
      background:rgba(0,0,0,.25);
      border:1px solid var(--line);
      border-radius:14px;
      padding:6px;
      overflow:hidden; /* no scrolling */
      width:100%;
      height:100%;
      justify-content:center;
      align-content:center;
    }
    .cell{
      position:relative;
      border-radius:8px;
      border:1px solid rgba(0,0,0,.15);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:13px;
      font-weight:800;
      color:#f4f7fb;
      text-shadow:0 1px 1px rgba(0,0,0,.55);
      user-select:none;
      cursor:pointer;
      overflow:hidden;
      height: var(--cell);
      width: var(--cell);
      min-width:0;
      min-height:0;
    }
    .cell .lbl{position:relative; z-index:2}
    .cell.sel{
      outline:2px solid rgba(106,166,255,.9);
      outline-offset:-2px;
    }
    .cell .hint{
      position:absolute;
      right:6px; bottom:4px;
      font-size:10px;
      color:rgba(255,255,255,.75);
      z-index:2;
      opacity:.0;
      transition:opacity .15s ease;
    }
    .cell:hover .hint{opacity:.85}
    .legend{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      color:var(--muted);
      font-size:12px;
    }

    .toast{
      position:fixed;
      bottom:14px; left:14px;
      background:rgba(16,24,36,.92);
      border:1px solid var(--line);
      padding:10px 12px;
      border-radius:12px;
      box-shadow: var(--shadow);
      color:var(--text);
      font-size:13px;
      opacity:0;
      transform: translateY(8px);
      transition: opacity .2s ease, transform .2s ease;
      pointer-events:none;
      z-index:999;
    }
    .toast.show{
      opacity:1;
      transform: translateY(0);
    }

    .reportList{
      max-height:260px;
      overflow:auto;
      display:flex;
      flex-direction:column;
      gap:8px;
      padding-right:6px;
    }
    .report{
      border:1px solid var(--line);
      background:rgba(15,22,33,.75);
      border-radius:12px;
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:6px;
      font-size:13px;
    }

    .textInput{
      width:100%;
      border:1px solid var(--line);
      background:rgba(10,14,20,.35);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      outline:none;
    }
    .textInput:focus{
      border-color:rgba(106,166,255,.45);
      box-shadow: 0 0 0 4px rgba(106,166,255,.12);
    }

    .inspectBox{
      border:1px solid var(--line);
      background:rgba(15,22,33,.55);
      border-radius:14px;
      padding:10px 12px;
    }
    .inspectTitle{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .inspectTitle b{font-size:13px}
    .inspectRow{
      margin-top:8px;
      display:flex; gap:8px; flex-wrap:wrap;
    }
  </style>
</head>
<body>
  <div class="topbar">
    <div class="brand">
      <div class="dot"></div>
      <div>
        <strong>Preflop Trainer</strong>
        <div class="tiny muted">Cloudflare Pages · localStorage</div>
      </div>
    </div>

    <div class="seg" id="modeSeg">
      <button data-mode="trainer" class="active">Trainer</button>
      <button data-mode="editor">Editor</button>
      <button data-mode="library">Library</button>
      <button data-mode="reports">Reports</button>
    </div>

    <div class="seg" id="formatSeg" title="MTT and Cash are separate scenario libraries">
      <button data-format="MTT" class="active">MTT</button>
      <button data-format="Cash">Cash</button>
    </div>

    <div class="spacer"></div>

    <!-- Editor Save controls -->
    <div class="row" id="topEditorControls" style="display:none;"></div>

    <div class="pill"><span class="muted">Session</span> <b id="sessStat">—</b></div>
    <button class="btn small" id="btnResetAll">Reset site data</button>
  </div>

  <div class="main">
    <div class="left" id="leftPane">
      <div class="panel" style="margin:14px; margin-bottom:10px;">
        <div class="panelHeader">
          <h3 id="scenarioPanelTitle">Scenarios</h3>
          <div class="spacer"></div>
          <div class="row" id="scenarioHeaderActions"></div>
          <input id="fileImport" type="file" accept=".json" multiple style="display:none" />
        </div>
        <div class="panelBody">
          <div class="row" style="justify-content:space-between;">
            <div class="pill"><span class="muted">Loaded</span> <b id="scenarioCount">0</b></div>
            <div class="pill"><span class="muted">Selected</span> <b id="scenarioSelectedCount">0</b></div>
          </div>

          <div class="hr"></div>

          <div class="list" id="scenarioList"></div>

          <div class="hr"></div>

          <div class="row">
            <button class="btn small" id="btnSelectAll">Select all</button>
            <button class="btn small" id="btnSelectNone">Select none</button>
          </div>

          <div class="tiny muted" style="margin-top:10px;" id="scenarioPanelHint">
            MTT/Cash are separate scenario lists.
          </div>
        </div>
      </div>

      <div class="panel" style="margin:0 14px 14px;">
        <div class="panelHeader">
          <h3 id="leftTitle">Controls</h3>
          <div class="spacer"></div>
          <span class="badge mono" id="hotkeyHint">Hotkeys: X,C,Z,1..9, Enter</span>
        </div>
        <div class="panelBody" id="leftBody"></div>
      </div>
    </div>

    <div class="divider" id="dragDivider" title="Drag to resize"></div>

    <div class="right">
      <div class="panel">
        <div class="panelHeader">
          <h3 id="mainTitle">Trainer</h3>
          <div class="spacer"></div>
          <span class="tag" id="scenarioTag">—</span>
          <span class="tag" id="formatTag">Format: MTT</span>
        </div>
        <div class="panelBody" id="mainBody" style="height: calc(100vh - 56px - 14px - 14px - 70px);"></div>
      </div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

<script>
(() => {
  // Storage keys (new schema)
  const LS_SCEN = "pokerTrainerScenarios_v2";
  const LS_REP  = "pokerTrainerReports_v2";
  const LS_UI   = "pokerTrainerUI_v2";

  const RANKS = "AKQJT98765432";

  // DOM refs
  const modeSeg = document.getElementById("modeSeg");
  const formatSeg = document.getElementById("formatSeg");
  const leftTitle = document.getElementById("leftTitle");
  const leftBody  = document.getElementById("leftBody");
  const mainTitle = document.getElementById("mainTitle");
  const mainBody  = document.getElementById("mainBody");
  const scenarioList = document.getElementById("scenarioList");
  const scenarioCount = document.getElementById("scenarioCount");
  const scenarioSelectedCount = document.getElementById("scenarioSelectedCount");
  const scenarioTag = document.getElementById("scenarioTag");
  const formatTag = document.getElementById("formatTag");
  const sessStat = document.getElementById("sessStat");

  const scenarioHeaderActions = document.getElementById("scenarioHeaderActions");
  const scenarioPanelTitle = document.getElementById("scenarioPanelTitle");
  const scenarioPanelHint = document.getElementById("scenarioPanelHint");
  const fileImport = document.getElementById("fileImport");

  const topEditorControls = document.getElementById("topEditorControls");

  // Utils
  function toast(msg){
    const el = document.getElementById("toast");
    el.textContent = msg;
    el.classList.add("show");
    setTimeout(() => el.classList.remove("show"), 1800);
  }
  function nowISO(){ return new Date().toISOString(); }
  function loadJSON(key, fallback){
    try{
      const s = localStorage.getItem(key);
      if(!s) return fallback;
      return JSON.parse(s);
    }catch{ return fallback; }
  }
  function saveJSON(key, val){ localStorage.setItem(key, JSON.stringify(val)); }
  function escapeHTML(s){
    return String(s).replace(/[&<>"']/g, (c) => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
    }[c]));
  }
  function safeName(s){
    return String(s).replace(/[^A-Za-z0-9._-]+/g, "_").slice(0, 160);
  }
  function downloadJSON(obj, filename){
    const blob = new Blob([JSON.stringify(obj, null, 2)], {type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    URL.revokeObjectURL(a.href);
    a.remove();
  }
  function getCSS(varName){
    return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
  }
  function byId(id){ return document.getElementById(id); }

  // Grid fit
  function fitAllGrids(){ document.querySelectorAll(".grid").forEach(g => fitGrid(g)); }
  function fitGrid(gridEl){
    if(!gridEl) return;
    const rect = gridEl.getBoundingClientRect();
    if(rect.width < 60 || rect.height < 60) return;

    const cs = getComputedStyle(gridEl);
    const gap = parseFloat(cs.gap || cs.columnGap || "2") || 2;
    const padL = parseFloat(cs.paddingLeft || "6") || 6;
    const padR = parseFloat(cs.paddingRight || "6") || 6;
    const padT = parseFloat(cs.paddingTop || "6") || 6;
    const padB = parseFloat(cs.paddingBottom || "6") || 6;

    const availW = rect.width - padL - padR - gap * 12;
    const availH = rect.height - padT - padB - gap * 12;

    const cellW = Math.floor(availW / 13);
    const cellH = Math.floor(availH / 13);

    let cell = Math.min(cellW, cellH);
    cell = Math.max(22, Math.min(48, cell));
    gridEl.style.setProperty("--cell", cell + "px");
  }
  let resizeT=null;
  window.addEventListener("resize", () => {
    clearTimeout(resizeT);
    resizeT = setTimeout(() => fitAllGrids(), 60);
  });

  // Scenario normalization
  function normalizeScenario(raw, assignFormat){
    if(!raw || typeof raw !== "object") throw new Error("Invalid JSON");
    const name = String(raw.name ?? raw.scenarioName ?? raw.title ?? "Unnamed Scenario");
    const tags = (raw.tags && typeof raw.tags==="object") ? raw.tags : {};
    const grid = raw.grid && typeof raw.grid==="object" ? raw.grid : null;
    if(!grid) throw new Error("Scenario missing grid");
    let actions = Array.isArray(raw.actions) ? raw.actions.map(String) : null;
    if(!actions){
      const anyHand = Object.keys(grid)[0];
      if(!anyHand) throw new Error("Empty grid");
      actions = Object.keys(grid[anyHand] || {}).map(String);
    }
    if(!actions.includes("Fold")) actions.unshift("Fold");

    for(const hand of Object.keys(grid)){
      const obj = grid[hand] || {};
      for(const a of actions){
        if(obj[a] == null) obj[a] = 0;
      }
      for(const k of Object.keys(obj)){
        if(!actions.includes(k)) delete obj[k];
      }
      grid[hand] = obj;
    }

    const format = String(raw.format || tags.format || assignFormat || "MTT");
    return {
      id: raw.id || crypto.randomUUID(),
      name,
      actions,
      tags: {...tags, format},
      format,
      grid,
      created: raw.created || "import",
      updatedAt: nowISO(),
    };
  }

  // State
  const state = {
    mode: "trainer",
    format: "MTT",

    scenariosAll: [],                    // all scenarios across formats
    selectedIdsByFormat: { MTT: new Set(), Cash: new Set() },

    // browsing (outside edit mode)
    browseScenarioIdByFormat: { MTT: null, Cash: null },
    inspect: { hand:null, scenarioId:null }, // clicked cell inspector

    // Trainer session
    sessionLen: 20,
    sessionActive: false,
    sessionQueue: [],
    currentIdx: 0,
    currentHand: null,
    reveal: false,
    attempts: [],

    // Editor
    editorScenarioId: null,
    editorDraft: null,
    editorDirty: false,
    paintDown: false,
    selectedCells: new Set(),
    palette: {},
  };

  // Migration: if old v1 key exists, pull into v2 (as MTT) once
  function migrateV1IfNeeded(){
    const v2 = localStorage.getItem(LS_SCEN);
    if(v2) return;
    const old = localStorage.getItem("pokerTrainerScenarios_v1");
    if(!old) return;
    try{
      const arr = JSON.parse(old);
      if(Array.isArray(arr)){
        const converted = arr.map(s => {
          // preserve existing as MTT by default
          const raw = {...s};
          raw.format = raw.format || (raw.tags?.format) || "MTT";
          return normalizeScenario(raw, raw.format);
        });
        saveJSON(LS_SCEN, converted);
      }
    }catch{}
  }

  function loadUI(){
    const ui = loadJSON(LS_UI, null);
    if(ui && typeof ui === "object"){
      if(ui.leftWidth) document.getElementById("leftPane").style.width = ui.leftWidth + "px";
      if(ui.format === "MTT" || ui.format === "Cash") state.format = ui.format;
      if(ui.selectedIdsByFormat){
        for(const fmt of ["MTT","Cash"]){
          const arr = ui.selectedIdsByFormat[fmt];
          if(Array.isArray(arr)) state.selectedIdsByFormat[fmt] = new Set(arr);
        }
      }
      if(ui.browseScenarioIdByFormat){
        for(const fmt of ["MTT","Cash"]){
          const id = ui.browseScenarioIdByFormat[fmt];
          if(typeof id === "string") state.browseScenarioIdByFormat[fmt] = id;
        }
      }
    }
  }
  function saveUI(){
    saveJSON(LS_UI, {
      leftWidth: parseInt(document.getElementById("leftPane").style.width || "360", 10),
      format: state.format,
      selectedIdsByFormat: {
        MTT: [...state.selectedIdsByFormat.MTT],
        Cash: [...state.selectedIdsByFormat.Cash],
      },
      browseScenarioIdByFormat: state.browseScenarioIdByFormat,
    });
  }

  function loadScenarios(){
    const arr = loadJSON(LS_SCEN, []);
    state.scenariosAll = Array.isArray(arr) ? arr : [];
    // Ensure format field exists
    for(const s of state.scenariosAll){
      if(!s.id) s.id = crypto.randomUUID();
      const fmt = s.format || s.tags?.format || "MTT";
      s.format = (fmt === "Cash") ? "Cash" : "MTT";
      s.tags = s.tags || {};
      s.tags.format = s.format;
    }
    // Default select all per format if empty
    for(const fmt of ["MTT","Cash"]){
      if(state.selectedIdsByFormat[fmt].size === 0){
        state.scenariosAll.filter(s => s.format === fmt).forEach(s => state.selectedIdsByFormat[fmt].add(s.id));
      }
      // Default browse scenario
      if(!state.browseScenarioIdByFormat[fmt]){
        const first = state.scenariosAll.find(s => s.format === fmt);
        state.browseScenarioIdByFormat[fmt] = first ? first.id : null;
      }
    }
  }
  function saveScenarios(){ saveJSON(LS_SCEN, state.scenariosAll); saveUI(); }

  function getVisibleScenarios(){
    return state.scenariosAll.filter(s => s.format === state.format);
  }
  function getSelectedSet(){
    return state.selectedIdsByFormat[state.format];
  }
  function setSelectedSet(newSet){
    state.selectedIdsByFormat[state.format] = newSet;
    saveUI();
  }
  function getBrowseScenarioId(){
    return state.browseScenarioIdByFormat[state.format];
  }
  function setBrowseScenarioId(id){
    state.browseScenarioIdByFormat[state.format] = id;
    saveUI();
  }
  function getScenarioById(id){
    return state.scenariosAll.find(s => s.id === id) || null;
  }

  function loadReports(){
    const arr = loadJSON(LS_REP, []);
    return Array.isArray(arr) ? arr : [];
  }
  function addReport(report){
    const arr = loadReports();
    arr.unshift(report);
    saveJSON(LS_REP, arr.slice(0, 200));
  }

  migrateV1IfNeeded();
  loadUI();
  loadScenarios();

  // URL autoplay (new-tab Play)
  function applyAutoplayFromURL(){
    const u = new URL(window.location.href);
    const fmt = u.searchParams.get("format");
    const playId = u.searchParams.get("play");
    const mode = u.searchParams.get("mode");
    if(fmt === "MTT" || fmt === "Cash") state.format = fmt;
    if(mode && ["trainer","editor","library","reports"].includes(mode)) state.mode = mode;

    if(playId){
      const sc = getScenarioById(playId);
      if(sc && sc.format === state.format){
        setBrowseScenarioId(sc.id);
        // select only this scenario for this format
        setSelectedSet(new Set([sc.id]));
        // start immediately if in trainer
        state.mode = "trainer";
        syncModeUI();
        startSessionForScenarioId(sc.id);
        // clean URL (optional)
        u.searchParams.delete("play");
        u.searchParams.delete("mode");
        history.replaceState({}, "", u.toString());
        toast("Started in new tab");
      }
    }
  }

  // Actions / colors / gradients
  function actionColor(action){
    const a = String(action).toLowerCase();
    if(a === "fold") return getCSS("--fold");
    if(a === "call") return getCSS("--call");
    if(a === "jam" || a === "allin" || a === "all-in") return getCSS("--jam");
    if(a.startsWith("raise")){
      const m = a.match(/raise\s*(\d+)/i);
      if(m){
        const n = parseInt(m[1], 10);
        return n <= 1 ? getCSS("--raise") : getCSS("--raise2");
      }
      return getCSS("--raise");
    }
    return "#777";
  }

  function normalizePctMap(map, actions){
    let sum = 0;
    const out = {};
    for(const a of actions){
      let v = Number(map[a] ?? 0);
      if(!Number.isFinite(v)) v = 0;
      v = Math.max(0, v);
      out[a] = v;
      sum += v;
    }
    if(sum <= 0){
      out["Fold"] = 100;
      for(const a of actions){
        if(a !== "Fold") out[a] = 0;
      }
      return out;
    }
    for(const a of actions){
      out[a] = (out[a] * 100) / sum;
    }
    let sum2 = 0, maxA = actions[0], maxV = -1;
    for(const a of actions){
      sum2 += out[a];
      if(out[a] > maxV){ maxV = out[a]; maxA = a; }
    }
    out[maxA] += (100 - sum2);
    return out;
  }

  function buildGradientForCell(pctMap, actions){
    const parts = [];
    let start = 0;
    for(const a of actions){
      const v = Math.max(0, Number(pctMap[a] ?? 0));
      if(v <= 0.001) continue;
      const end = start + v;
      const col = actionColor(a);
      parts.push(`${col} ${start.toFixed(2)}% ${end.toFixed(2)}%`);
      start = end;
    }
    if(parts.length === 0){
      return `linear-gradient(to right, ${getCSS("--panel2")} 0% 100%)`;
    }
    if(start < 100){
      parts.push(`${getCSS("--panel2")} ${start.toFixed(2)}% 100%`);
    }
    return `linear-gradient(to right, ${parts.join(", ")})`;
  }

  // 169 combo labels
  function labelFromRC(r,c){
    const hi = RANKS[Math.min(r,c)];
    const lo = RANKS[Math.max(r,c)];
    if(r===c) return hi+lo;
    return r < c ? `${hi}${lo}s` : `${hi}${lo}o`;
  }
  function allComboLabels(){
    const out=[];
    for(let r=0;r<13;r++){
      for(let c=0;c<13;c++){
        out.push(labelFromRC(r,c));
      }
    }
    return out;
  }
  const ALL_LABELS = allComboLabels();
  function randomHandLabel(){
    return ALL_LABELS[Math.floor(Math.random()*ALL_LABELS.length)];
  }

  // Cards (stable per hand)
  const suits = [
    {s:"♠", cls:"blackSuit"}, {s:"♥", cls:"redSuit"},
    {s:"♦", cls:"redSuit"},   {s:"♣", cls:"blackSuit"},
  ];
  function handToTwoCards(hand){
    const r1 = hand[0], r2 = hand[1];
    const suited = hand.length === 3 && hand[2] === "s";
    let s1, s2;
    if(r1 === r2){
      s1 = suits[Math.floor(Math.random()*4)];
      do { s2 = suits[Math.floor(Math.random()*4)]; } while(s2.s === s1.s);
    }else if(suited){
      s1 = suits[Math.floor(Math.random()*4)];
      s2 = s1;
    }else{
      s1 = suits[Math.floor(Math.random()*4)];
      do { s2 = suits[Math.floor(Math.random()*4)]; } while(s2.s === s1.s);
    }
    return [
      {rank:r1, suit:s1.s, cls:s1.cls},
      {rank:r2, suit:s2.s, cls:s2.cls},
    ];
  }
  function renderCardHTML(c){
    return `
      <div class="card">
        <div class="r ${c.cls}">${c.rank}</div>
        <div class="s ${c.cls}">${c.suit}</div>
        <div class="mid ${c.cls}">${c.suit}</div>
      </div>
    `;
  }

  // Raise size sorting + hotkeys
  function sortRaisesSmallToLarge(raises){
    const key = (a)=>{
      const m = a.toLowerCase().match(/raise\s*(\d+)/i);
      if(m) return parseInt(m[1],10);
      return 1;
    };
    return [...raises].sort((a,b)=>key(a)-key(b));
  }
  function numberedAggroActions(scenario){
    const raises = sortRaisesSmallToLarge(scenario.actions.filter(a => a.toLowerCase().startsWith("raise")));
    const out = [...raises];
    if(scenario.actions.some(a => a.toLowerCase() === "jam")) out.push("Jam");
    return out;
  }

  // RNG scoring
  function aggressionOrder(actions){
    const raises = actions.filter(a => a.toLowerCase().startsWith("raise"));
    const jam = actions.filter(a => a.toLowerCase() === "jam");
    const call = actions.filter(a => a.toLowerCase() === "call");
    const fold = actions.filter(a => a.toLowerCase() === "fold");
    const raiseKey = (a) => {
      const m = a.toLowerCase().match(/raise\s*(\d+)/);
      if(m) return parseInt(m[1],10);
      return 1;
    };
    raises.sort((a,b) => raiseKey(b) - raiseKey(a));
    return [...jam, ...raises, ...call, ...fold];
  }

  function pickSolverAction(pctMap, actions){
    const order = aggressionOrder(actions);
    const norm = normalizePctMap(pctMap, actions);
    const rng = Math.floor(Math.random()*100) + 1;
    let cum = 0;
    let choice = order[order.length-1] || "Fold";
    for(const a of order){
      cum += Math.max(0, Number(norm[a] ?? 0));
      if(rng <= cum){
        choice = a;
        break;
      }
    }
    return {rng, choice, normalized: norm};
  }

  function scoreAttempt(userAction, solverChoice, pctMap, actions){
    const norm = normalizePctMap(pctMap, actions);
    const used = Number(norm[userAction] ?? 0) > 0.0001;
    if(userAction === solverChoice) return {tier:"best", pts:100};
    if(used) return {tier:"correct", pts:70};
    return {tier:"wrong", pts:0};
  }

  // Inspector (click cell -> show %)
  function setInspector(scenarioId, hand){
    state.inspect = { scenarioId, hand };
    // Re-render only the right panel; simplest is full mode render.
    renderMain();
  }
  function renderInspectorHTML(){
    const {scenarioId, hand} = state.inspect;
    if(!scenarioId || !hand) {
      return `
        <div class="inspectBox">
          <div class="inspectTitle">
            <b>Cell inspector</b>
            <span class="badge mono">Click a hand</span>
          </div>
          <div class="tiny muted" style="margin-top:6px;">Works in Trainer (when grid visible) and Library browse.</div>
        </div>
      `;
    }
    const s = getScenarioById(scenarioId);
    if(!s) return `
      <div class="inspectBox"><b>Cell inspector</b><div class="tiny muted">Scenario not found.</div></div>
    `;
    const pct = s.grid?.[hand] || {};
    const norm = normalizePctMap(pct, s.actions);
    return `
      <div class="inspectBox">
        <div class="inspectTitle">
          <b>Cell: <span class="mono">${escapeHTML(hand)}</span></b>
          <span class="tag"><span class="mono">${escapeHTML(s.name)}</span></span>
        </div>
        <div class="inspectRow">
          ${s.actions.map(a => {
            const v = Math.round((norm[a]||0)*10)/10;
            return `<span class="tag"><span class="sw" style="background:${actionColor(a)}"></span>${escapeHTML(a)}: <b>${v}%</b></span>`;
          }).join("")}
        </div>
      </div>
    `;
  }

  // Scenario header actions
  function renderScenarioHeaderActions(){
    scenarioHeaderActions.innerHTML = "";

    const mkBtn = (label, cls, onClick) => {
      const b = document.createElement("button");
      b.className = `btn small ${cls||""}`.trim();
      b.textContent = label;
      b.addEventListener("click", onClick);
      return b;
    };

    if(state.mode === "library"){
      const importBtn = document.createElement("button");
      importBtn.className = "btn small";
      importBtn.textContent = "Import JSON";
      importBtn.addEventListener("click", ()=> fileImport.click());
      scenarioHeaderActions.appendChild(importBtn);

      scenarioHeaderActions.appendChild(mkBtn("New", "primary", () => createNewScenario(true)));
      scenarioHeaderActions.appendChild(mkBtn("Export selected", "", exportSelectedScenarios));
      scenarioHeaderActions.appendChild(mkBtn("Delete selected", "danger", deleteSelectedScenarios));
      scenarioPanelHint.textContent = "Library: click a scenario name to browse its grid + click cells to inspect.";

    } else if(state.mode === "trainer"){
      scenarioHeaderActions.appendChild(mkBtn("New", "primary", () => createNewScenario(true)));
      scenarioPanelHint.textContent = "Trainer: click a scenario name to browse, or hit ▶ to train just that scenario.";

    } else if(state.mode === "editor"){
      scenarioHeaderActions.appendChild(mkBtn("New", "primary", () => createNewScenario(true)));
      scenarioPanelHint.textContent = "Editor: paint ranges. Save (Ctrl/⌘+S) to keep changes.";

    } else if(state.mode === "reports"){
      scenarioPanelHint.textContent = "Reports: sessions stored locally in this browser.";
    }

    scenarioPanelTitle.textContent = `Scenarios (${state.format})`;
  }

  // Scenario list
  function renderScenarioList(){
    scenarioList.innerHTML = "";
    const visible = getVisibleScenarios();
    const selectedSet = getSelectedSet();
    scenarioCount.textContent = String(visible.length);
    scenarioSelectedCount.textContent = String(selectedSet.size);

    const sorted = [...visible].sort((a,b) => (a.name||"").localeCompare(b.name||""));

    const compact = (state.mode === "trainer");

    for(const s of sorted){
      const checked = selectedSet.has(s.id);
      const el = document.createElement("div");
      el.className = "item";

      if(compact){
        el.innerHTML = `
          <div class="itemCompact">
            <div class="itemLeft">
              <input type="checkbox" ${checked ? "checked":""} data-id="${s.id}" />
              <div class="itemName" title="${escapeHTML(s.name)}" data-browse="${s.id}">
                ${escapeHTML(s.name)}
              </div>
            </div>
            <div class="itemIcons">
              <button class="iconBtn primary" title="Play this scenario (Ctrl/Cmd/Shift: new tab)" data-play="${s.id}">▶</button>
              <button class="iconBtn" title="Edit" data-edit="${s.id}">✎</button>
            </div>
          </div>
        `;
      } else {
        // Non-trainer list (more info + edit)
        el.innerHTML = `
          <div class="itemTop">
            <div style="display:flex; gap:10px; align-items:flex-start;">
              <input type="checkbox" ${checked ? "checked":""} data-id="${s.id}" />
              <div>
                <div class="itemTitle" data-browse="${s.id}" title="Browse grid">${escapeHTML(s.name)}</div>
                <div class="itemMeta">
                  <span class="tag">Actions: ${escapeHTML((s.actions||[]).join(", "))}</span>
                  <span class="tag">Format: <b>${escapeHTML(s.format)}</b></span>
                </div>
              </div>
            </div>
            <div style="display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end;">
              <button class="iconBtn" title="Edit" data-edit="${s.id}">✎</button>
            </div>
          </div>
        `;
      }

      scenarioList.appendChild(el);
    }

    scenarioList.querySelectorAll('input[type="checkbox"][data-id]').forEach(cb => {
      cb.addEventListener("change", (e) => {
        const id = e.target.getAttribute("data-id");
        const set = new Set([...getSelectedSet()]);
        if(e.target.checked) set.add(id);
        else set.delete(id);
        setSelectedSet(set);
        scenarioSelectedCount.textContent = String(set.size);
      });
    });

    scenarioList.querySelectorAll('[data-edit]').forEach(btn => {
      btn.addEventListener("click", () => openEditor(btn.getAttribute("data-edit")));
    });

    scenarioList.querySelectorAll('[data-browse]').forEach(btn => {
      btn.addEventListener("click", () => {
        const id = btn.getAttribute("data-browse");
        setBrowseScenarioId(id);
        // reset inspector to avoid mismatch if switching scenarios
        state.inspect = { scenarioId: id, hand: null };
        renderMain();
      });
    });

    scenarioList.querySelectorAll('[data-play]').forEach(btn => {
      btn.addEventListener("click", (ev) => {
        const id = btn.getAttribute("data-play");
        if(ev.ctrlKey || ev.metaKey || ev.shiftKey){
          const u = new URL(window.location.href);
          u.searchParams.set("mode","trainer");
          u.searchParams.set("format", state.format);
          u.searchParams.set("play", id);
          window.open(u.toString(), "_blank");
          return;
        }
        // same tab: select only this scenario and start
        setBrowseScenarioId(id);
        setSelectedSet(new Set([id]));
        state.mode = "trainer";
        syncModeUI();
        startSessionForScenarioId(id);
      });
    });
  }

  // Create new scenario
  function emptyGridForActions(actions){
    const grid = {};
    for(const hand of ALL_LABELS){
      const obj = {};
      for(const a of actions) obj[a] = 0;
      obj["Fold"] = 100;
      grid[hand] = obj;
    }
    return grid;
  }

  function createNewScenario(openEditorAfter=true){
    const name = (prompt(`Scenario name (will be saved under ${state.format})\nExample: 20bb - BTN - RFI`) || "").trim();
    if(!name) return;

    const includeCall = (prompt("Include Call/Limp action? (y/n)", "n") || "n").trim().toLowerCase().startsWith("y");
    const raiseCountRaw = (prompt("How many non-jam raise sizes? (0-6)", "1") || "1").trim();
    let raiseCount = parseInt(raiseCountRaw, 10);
    if(!Number.isFinite(raiseCount) || raiseCount < 0) raiseCount = 0;
    if(raiseCount > 6) raiseCount = 6;

    const includeJam = (prompt("Include Jam (all-in) action? (y/n)", "y") || "y").trim().toLowerCase().startsWith("y");

    const actions = ["Fold"];
    if(includeCall) actions.push("Call");
    for(let i=1;i<=raiseCount;i++){
      actions.push(`Raise ${i}`);
    }
    if(includeJam) actions.push("Jam");

    const scen = {
      id: crypto.randomUUID(),
      name,
      actions,
      tags: { format: state.format },
      format: state.format,
      grid: emptyGridForActions(actions),
      created: "local",
      updatedAt: nowISO(),
    };

    state.scenariosAll.push(scen);
    // select it in its format
    const set = new Set([...getSelectedSet()]);
    set.add(scen.id);
    setSelectedSet(set);
    setBrowseScenarioId(scen.id);

    saveScenarios();
    renderScenarioList();
    toast("Created scenario");

    if(openEditorAfter) openEditor(scen.id);
  }

  // Import / export / delete
  fileImport.addEventListener("change", async (e) => {
    const files = Array.from(e.target.files || []);
    if(!files.length) return;

    let added = 0;
    for(const f of files){
      try{
        const text = await f.text();
        const raw = JSON.parse(text);
        const scen = normalizeScenario(raw, state.format);

        // upsert by name within same format
        const idx = state.scenariosAll.findIndex(s => s.format === scen.format && s.name === scen.name);
        if(idx >= 0){
          scen.id = state.scenariosAll[idx].id;
          state.scenariosAll[idx] = scen;
        }else{
          state.scenariosAll.push(scen);
        }

        // select it
        const set = new Set([...state.selectedIdsByFormat[scen.format]]);
        set.add(scen.id);
        state.selectedIdsByFormat[scen.format] = set;

        // browse it if on this format
        if(scen.format === state.format) setBrowseScenarioId(scen.id);

        added++;
      }catch(err){
        console.error(err);
        toast(`Failed: ${f.name}`);
      }
    }

    saveScenarios();
    renderScenarioList();
    toast(`Imported ${added} scenario(s) to ${state.format}`);
    e.target.value = "";
  });

  function exportSelectedScenarios(){
    const selectedSet = getSelectedSet();
    const list = getVisibleScenarios().filter(s => selectedSet.has(s.id));
    if(list.length === 0) return toast("No scenarios selected");
    if(list.length === 1){
      downloadJSON(list[0], safeName(list[0].name) + ".json");
    }else{
      list.forEach((sc, i) => {
        setTimeout(() => downloadJSON(sc, safeName(sc.name) + ".json"), i * 120);
      });
      toast(`Downloading ${list.length} files...`);
    }
  }

  function deleteSelectedScenarios(){
    const selectedSet = getSelectedSet();
    const ids = [...selectedSet];
    if(!ids.length) return toast("No scenarios selected");
    if(!confirm(`Delete ${ids.length} selected scenario(s) from ${state.format} on this browser?`)) return;

    state.scenariosAll = state.scenariosAll.filter(s => !(s.format === state.format && selectedSet.has(s.id)));

    // reset selection to all remaining in this format
    const remain = getVisibleScenarios();
    setSelectedSet(new Set(remain.map(s => s.id)));

    // fix browse
    const b = getBrowseScenarioId();
    const stillExists = b && getScenarioById(b) && getScenarioById(b).format === state.format;
    if(!stillExists){
      setBrowseScenarioId(remain[0]?.id || null);
    }

    // if editing deleted scenario
    if(state.editorScenarioId && !getScenarioById(state.editorScenarioId)) closeEditor();

    saveScenarios();
    renderScenarioList();
    toast("Deleted");
    renderMain();
  }

  byId("btnSelectAll").addEventListener("click", () => {
    setSelectedSet(new Set(getVisibleScenarios().map(s => s.id)));
    renderScenarioList();
  });
  byId("btnSelectNone").addEventListener("click", () => {
    setSelectedSet(new Set());
    renderScenarioList();
  });

  // Editor save controls in top bar
  function renderTopEditorControls(){
    if(state.mode !== "editor" || !state.editorDraft){
      topEditorControls.style.display = "none";
      topEditorControls.innerHTML = "";
      return;
    }
    topEditorControls.style.display = "flex";
    topEditorControls.innerHTML = `
      <span class="badge ${state.editorDirty ? "warn" : "good"}">${state.editorDirty ? "Unsaved changes" : "Saved"}</span>
      <button class="btn small primary" id="topSave" ${state.editorDirty ? "" : "disabled"}>Save (Ctrl/⌘+S)</button>
      <button class="btn small" id="topDiscard" ${state.editorDirty ? "" : "disabled"}>Discard</button>
    `;
    topEditorControls.querySelector("#topSave").addEventListener("click", saveEditorChanges);
    topEditorControls.querySelector("#topDiscard").addEventListener("click", discardEditorChanges);
  }

  // Mode switching
  function syncModeUI(){
    modeSeg.querySelectorAll("button").forEach(b => {
      b.classList.toggle("active", b.getAttribute("data-mode") === state.mode);
    });
    formatSeg.querySelectorAll("button").forEach(b => {
      b.classList.toggle("active", b.getAttribute("data-format") === state.format);
    });

    formatTag.textContent = `Format: ${state.format}`;
    renderScenarioHeaderActions();
    renderScenarioList();
    renderTopEditorControls();
    renderLeft();
    renderMain();
    saveUI();
    setTimeout(() => fitAllGrids(), 0);
  }

  modeSeg.addEventListener("click", (e) => {
    const btn = e.target.closest("button[data-mode]");
    if(!btn) return;

    if(state.mode === "editor" && state.editorDirty){
      const ok = confirm("You have unsaved changes. Leave without saving?");
      if(!ok) return;
    }
    state.mode = btn.getAttribute("data-mode");
    syncModeUI();
  });

  formatSeg.addEventListener("click", (e) => {
    const btn = e.target.closest("button[data-format]");
    if(!btn) return;

    if(state.mode === "editor" && state.editorDirty){
      const ok = confirm("You have unsaved changes. Switch format without saving?");
      if(!ok) return;
    }
    const nextFmt = btn.getAttribute("data-format");
    if(nextFmt === state.format) return;

    // stop current session when switching library
    if(state.sessionActive){
      state.sessionActive = false;
      state.sessionQueue = [];
      state.currentHand = null;
      state.reveal = false;
      state.attempts = [];
      sessStat.textContent = "—";
    }

    state.format = nextFmt;
    // ensure browse is set
    if(!getBrowseScenarioId()){
      const first = getVisibleScenarios()[0];
      setBrowseScenarioId(first ? first.id : null);
    }
    // reset inspector to current browse scenario
    const b = getBrowseScenarioId();
    state.inspect = { scenarioId: b, hand: null };
    closeEditor();
    syncModeUI();
  });

  // Warn on refresh/close if dirty
  window.addEventListener("beforeunload", (e) => {
    if(state.editorDirty){
      e.preventDefault();
      e.returnValue = "";
    }
  });

  byId("btnResetAll").addEventListener("click", () => {
    if(!confirm("Reset all site data? This deletes scenarios and reports from this browser.")) return;
    localStorage.removeItem(LS_SCEN);
    localStorage.removeItem(LS_REP);
    localStorage.removeItem(LS_UI);
    // also remove old v1 data if present
    localStorage.removeItem("pokerTrainerScenarios_v1");
    localStorage.removeItem("pokerTrainerReports_v1");
    localStorage.removeItem("pokerTrainerUI_v1");

    state.scenariosAll = [];
    state.selectedIdsByFormat = { MTT: new Set(), Cash: new Set() };
    state.browseScenarioIdByFormat = { MTT: null, Cash: null };
    state.inspect = {scenarioId:null, hand:null};
    state.sessionActive = false;

    saveScenarios();
    syncModeUI();
    toast("Reset complete");
  });

  // Left pane renderer
  function renderLeft(){
    if(state.mode === "trainer") renderTrainerLeft();
    else if(state.mode === "editor") renderEditorLeft();
    else if(state.mode === "library") renderLibraryLeft();
    else if(state.mode === "reports") renderReportsLeft();
  }

  // Main pane renderer
  function renderMain(){
    if(state.mode === "trainer") renderTrainerMain();
    else if(state.mode === "editor") renderEditorMain();
    else if(state.mode === "library") renderLibraryMain();
    else if(state.mode === "reports") renderReportsMain();
  }

  // Trainer UI
  function renderTrainerLeft(){
    leftTitle.textContent = "Trainer Controls";
    leftBody.innerHTML = `
      <div class="row" style="justify-content:space-between;">
        <div class="pill"><span class="muted">Session length</span> <b>${state.sessionLen}</b></div>
        <input id="sessLen" type="range" min="5" max="60" step="1" value="${state.sessionLen}" />
      </div>
      <div class="tiny muted">Default is 20 hands.</div>

      <div class="hr"></div>

      <div class="row">
        <button class="btn primary" id="btnStart">${state.sessionActive ? "Restart session" : "Start session"}</button>
        <button class="btn" id="btnStop" ${state.sessionActive ? "" : "disabled"}>Stop</button>
      </div>

      <div class="hr"></div>

      <div class="tiny muted">
        Hotkeys: X=Fold, C=Call, Z=Jam, 1..9=Raise sizes (Jam is largest), Enter=Next (after reveal).
      </div>
    `;

    leftBody.querySelector("#sessLen").addEventListener("input", (e)=>{
      state.sessionLen = Number(e.target.value);
      renderTrainerLeft();
    });

    leftBody.querySelector("#btnStart").addEventListener("click", startSession);
    leftBody.querySelector("#btnStop").addEventListener("click", stopSession);
  }

  function renderTrainerMain(){
    mainTitle.textContent = "Trainer";
    const browseId = getBrowseScenarioId();
    const browseScen = browseId ? getScenarioById(browseId) : null;
    scenarioTag.textContent = browseScen ? browseScen.name : "—";

    if(!state.sessionActive){
      // Browse mode: show grid for selected scenario (outside edit mode) + inspector
      if(!browseScen){
        mainBody.innerHTML = `
          ${renderInspectorHTML()}
          <div class="hr"></div>
          <div class="muted">No scenarios in ${state.format}. Go to Library → Import JSON or create a new scenario.</div>
        `;
        window.onkeydown = null;
        return;
      }

      mainBody.innerHTML = `
        ${renderInspectorHTML()}
        <div class="hr"></div>
        <div class="panel" style="background:rgba(15,22,33,.55); border:1px solid var(--line); border-radius:14px; padding:12px; height: calc(100vh - 56px - 14px - 14px - 70px - 120px);">
          <div class="row" style="justify-content:space-between; align-items:center;">
            <div>
              <div style="font-weight:900;">Browse grid (not training)</div>
              <div class="tiny muted">Click a cell to see action % in the inspector.</div>
            </div>
            <div class="row">
              <span class="tag">Actions: <b>${escapeHTML((browseScen.actions||[]).join(", "))}</b></span>
            </div>
          </div>
          <div class="hr"></div>
          <div style="height: calc(100% - 52px);">
            ${renderGridHTML(browseScen, null, false, { allowClickInspect:true, scenarioId:browseScen.id })}
          </div>
        </div>
      `;
      window.onkeydown = null;
      setTimeout(() => fitAllGrids(), 0);
      return;
    }

    const ch = state.currentHand;
    if(!ch){
      mainBody.innerHTML = `<div class="muted">Loading hand...</div>`;
      return;
    }

    const {scenario, hand, rng, solverChoice, normalized, cards} = ch;
    scenarioTag.textContent = scenario.name;

    const gridPanelHeight = "calc(100vh - 56px - 14px - 14px - 140px)";

    const hasCall = scenario.actions.some(a=>a.toLowerCase()==="call");
    const raiseActions = sortRaisesSmallToLarge(scenario.actions.filter(a=>a.toLowerCase().startsWith("raise")));
    const hasJam = scenario.actions.some(a=>a.toLowerCase()==="jam");

    const numbered = numberedAggroActions(scenario);
    const keyForAction = (act) => {
      const idx = numbered.findIndex(x => x.toLowerCase() === act.toLowerCase());
      return idx >= 0 ? String(idx+1) : "";
    };

    mainBody.innerHTML = `
      ${renderInspectorHTML()}
      <div class="hr"></div>

      <div class="row" style="justify-content:space-between; align-items:stretch; gap:14px;">
        <div class="col" style="gap:10px; flex:1; min-width:520px;">
          <div class="scenarioName">${escapeHTML(scenario.name)}</div>

          <div class="cards">
            ${renderCardHTML(cards[0])}
            ${renderCardHTML(cards[1])}
            <div class="pill"><span class="muted">Combo</span> <b class="mono">${hand}</b></div>
            <div class="pill"><span class="muted">Hand</span> <b class="mono">#${state.currentIdx+1}/${state.sessionQueue.length}</b></div>
          </div>

          <div class="rngBanner">RNG: ${rng}</div>

          <div class="panel" style="background:rgba(15,22,33,.55); border:1px solid var(--line); border-radius:14px; padding:12px;">
            <div class="actionBar" id="actionBar">
              <button class="actBtn actFold" data-act="Fold"><span>Fold</span><span class="k">X</span></button>
              ${hasCall ? `<button class="actBtn actCall" data-act="Call"><span>Call</span><span class="k">C</span></button>` : ``}

              ${raiseActions.map(a => `
                <button class="actBtn actRaise" data-act="${escapeHTML(a)}">
                  <span>${escapeHTML(a)}</span>
                  <span class="k">${keyForAction(a)}</span>
                </button>
              `).join("")}

              ${hasJam ? `
                <button class="actBtn actJam" data-act="Jam">
                  <span>All-in</span>
                  <span class="k">${keyForAction("Jam")}${keyForAction("Jam") ? " / " : ""}Z</span>
                </button>
              ` : ``}
            </div>

            <div class="hr"></div>

            <div id="revealBlock" style="display:${state.reveal ? "block":"none"};">
              <div class="row" style="justify-content:space-between; align-items:center;">
                <div>
                  <div style="font-weight:900; font-size:16px;">Solution</div>
                  <div class="tiny muted">RNG selected: <span class="mono">${escapeHTML(solverChoice)}</span></div>
                </div>
                <div class="row">
                  <span class="badge ${state.lastTierClass || ""}" id="lastScoreBadge" style="font-size:16px;padding:10px 14px;font-weight:900;border-radius:999px;">—</span>
                  <button class="btn primary" id="btnNext">Next hand <span class="mono">(Enter)</span></button>
                </div>
              </div>
              <div class="hr"></div>
              <div class="row">
                ${scenario.actions.map(a => {
                  const v = Math.round((normalized[a]||0)*10)/10;
                  return `<span class="tag"><span class="sw" style="background:${actionColor(a)}"></span>${escapeHTML(a)}: <b>${v}%</b></span>`;
                }).join("")}
              </div>
            </div>
          </div>
        </div>

        <div class="panel" style="flex:0 0 680px; max-width:45vw; min-width:560px; background:rgba(15,22,33,.55); border:1px solid var(--line); border-radius:14px; padding:12px; height:${gridPanelHeight};">
          <div class="row" style="justify-content:space-between; align-items:center;">
            <div>
              <div style="font-weight:900;">Range grid</div>
              <div class="tiny muted">${state.reveal ? "Click cells to inspect." : "Hidden until you act."}</div>
            </div>
            <div class="pill"><span class="muted">Format</span> <b>${escapeHTML(state.format)}</b></div>
          </div>
          <div class="hr"></div>
          <div style="height: calc(100% - 52px);">
            ${state.reveal
              ? renderGridHTML(scenario, hand, false, { allowClickInspect:true, scenarioId: scenario.id })
              : `<div class="muted">Make a decision to reveal the grid.</div>`
            }
          </div>
        </div>
      </div>
    `;

    const actionBar = document.getElementById("actionBar");
    actionBar.querySelectorAll("[data-act]").forEach(btn => {
      btn.addEventListener("click", () => handleUserAction(btn.getAttribute("data-act")));
    });

    if(state.reveal){
      document.getElementById("btnNext").addEventListener("click", nextHand);
    }

    window.onkeydown = (ev) => {
      if(!state.sessionActive) return;

      if(state.reveal && ev.key === "Enter"){
        ev.preventDefault();
        return nextHand();
      }
      if(state.reveal) return;

      const k = ev.key.toLowerCase();
      if(k === "x") return handleUserAction("Fold");
      if(k === "c" && hasCall) return handleUserAction("Call");
      if(k === "z" && hasJam) return handleUserAction("Jam");

      if(/^[1-9]$/.test(k)){
        const n = parseInt(k,10);
        const pick = numbered[n-1];
        if(pick) return handleUserAction(pick);
      }
    };

    setTimeout(() => fitAllGrids(), 0);
  }

  function startSession(){
    const visible = getVisibleScenarios();
    const selectedSet = getSelectedSet();
    const pool = visible.filter(s => selectedSet.has(s.id));
    if(pool.length === 0){
      toast("Select at least one scenario");
      return;
    }
    buildSessionFromPool(pool);
    syncModeUI();
    toast("Session started");
  }

  function startSessionForScenarioId(id){
    const sc = getScenarioById(id);
    if(!sc || sc.format !== state.format){
      toast("Scenario not available in this format");
      return;
    }
    buildSessionFromPool([sc]);
    syncModeUI();
    toast("Session started (single scenario)");
  }

  function buildSessionFromPool(pool){
    state.sessionQueue = [];
    for(let i=0;i<state.sessionLen;i++){
      const scen = pool[Math.floor(Math.random()*pool.length)];
      const hand = randomHandLabel();
      state.sessionQueue.push({scenarioId: scen.id, hand});
    }
    state.sessionActive = true;
    state.currentIdx = 0;
    state.attempts = [];
    state.reveal = false;
    setCurrentHandFromQueue();
  }

  function stopSession(){
    if(!state.sessionActive) return;
    endSessionAndReport("Stopped");
  }

  function setCurrentHandFromQueue(){
    const item = state.sessionQueue[state.currentIdx];
    if(!item){
      endSessionAndReport("Completed");
      return;
    }
    const scenario = getScenarioById(item.scenarioId);
    if(!scenario){
      state.currentIdx++;
      return setCurrentHandFromQueue();
    }
    const pctMap = scenario.grid[item.hand] || {};
    const pick = pickSolverAction(pctMap, scenario.actions);
    state.currentHand = {
      scenario,
      hand: item.hand,
      rng: pick.rng,
      solverChoice: pick.choice,
      normalized: pick.normalized,
      cards: handToTwoCards(item.hand),
    };
    state.reveal = false;
    state.lastTierClass = "";
    updateSessStat();

    // Ensure inspector targets current scenario (hand unset until click)
    state.inspect = { scenarioId: scenario.id, hand: null };
  }

  function updateSessStat(){
    if(!state.sessionActive){
      sessStat.textContent = "—";
      return;
    }
    const avg = state.attempts.length ? Math.round(state.attempts.reduce((a,x)=>a+x.pts,0)/state.attempts.length) : 0;
    sessStat.textContent = `${state.currentIdx+1}/${state.sessionQueue.length} · Score ${avg}%`;
  }

  function handleUserAction(action){
    const ch = state.currentHand;
    if(!ch || state.reveal) return;

    const scenario = ch.scenario;
    const actual = scenario.actions.find(a => a.toLowerCase() === String(action).toLowerCase());
    if(!actual){
      toast("Action not available in this scenario");
      return;
    }

    const {tier, pts} = scoreAttempt(actual, ch.solverChoice, ch.normalized, scenario.actions);
    state.attempts.push({
      ts: nowISO(),
      scenarioId: scenario.id,
      scenarioName: scenario.name,
      hand: ch.hand,
      rng: ch.rng,
      solverChoice: ch.solverChoice,
      userAction: actual,
      tier,
      pts,
      format: state.format,
    });

    state.reveal = true;
    state.lastTierClass = tier === "best" ? "good" : (tier==="correct" ? "warn" : "bad");
    renderTrainerMain();

    const badge = document.getElementById("lastScoreBadge");
    if(badge){
      badge.className = `badge ${state.lastTierClass}`;
      badge.textContent = tier === "best" ? `BEST · 100` : (tier==="correct" ? `CORRECT · 70` : `WRONG · 0`);
    }

    updateSessStat();
  }

  function nextHand(){
    state.currentIdx++;
    if(state.currentIdx >= state.sessionQueue.length){
      endSessionAndReport("Completed");
      return;
    }
    setCurrentHandFromQueue();
    renderTrainerMain();
  }

  function endSessionAndReport(status){
    const attempts = state.attempts;
    const avg = attempts.length ? (attempts.reduce((a,x)=>a+x.pts,0)/attempts.length) : 0;
    const best = attempts.filter(a=>a.tier==="best").length;
    const corr = attempts.filter(a=>a.tier==="correct").length;
    const wrong = attempts.filter(a=>a.tier==="wrong").length;

    addReport({
      id: crypto.randomUUID(),
      status,
      createdAt: nowISO(),
      format: state.format,
      sessionLen: state.sessionQueue.length,
      selectedScenarioCount: getSelectedSet().size,
      avgScore: Math.round(avg),
      breakdown: {best, correct:corr, wrong},
      attempts: attempts.slice(0, 500),
    });

    state.sessionActive = false;
    state.sessionQueue = [];
    state.currentIdx = 0;
    state.currentHand = null;
    state.reveal = false;

    syncModeUI();
    toast(`Session ${status}. Avg ${Math.round(avg)}%`);
  }

  // Grid renderer
  function renderGridHTML(scenario, highlightHand, selectable, opts){
    const actions = scenario.actions;
    const allowClickInspect = !!(opts && opts.allowClickInspect);
    const sid = opts && opts.scenarioId ? opts.scenarioId : scenario.id;

    const cells = [];
    for(let r=0;r<13;r++){
      for(let c=0;c<13;c++){
        const hand = labelFromRC(r,c);
        const pctMap = scenario.grid[hand] || {};
        const grad = buildGradientForCell(pctMap, actions);
        const isHL = hand === highlightHand;
        const isSel = state.selectedCells.has(hand);
        const cls = `cell ${isSel ? "sel":""}`;
        const hint = selectable ? `<div class="hint">paint</div>` : `<div class="hint">${isHL ? "you":""}</div>`;
        cells.push(`
          <div class="${cls}" data-hand="${hand}" data-sid="${sid}"
               style="background-image:${grad}; ${isHL ? "outline:2px solid rgba(255,204,102,.9); outline-offset:-2px;" : ""}">
            <div class="lbl mono">${hand}</div>
            ${hint}
          </div>
        `);
      }
    }
    const legend = `
      <div class="legend">
        ${actions.map(a => `<span><span class="sw" style="background:${actionColor(a)}"></span>${escapeHTML(a)}</span>`).join("")}
      </div>
    `;
    // attach click handler after render in parent (we do it by event delegation below)
    const clickHint = allowClickInspect ? `<div class="tiny muted">Tip: click a cell to inspect action %</div>` : ``;

    return `
      <div class="gridWrap" data-gridwrap="1" data-allowinspect="${allowClickInspect ? "1":"0"}">
        ${legend}
        ${clickHint}
        <div class="grid" id="grid">${cells.join("")}</div>
      </div>
    `;
  }

  // Editor
  function openEditor(id){
    const scen = getScenarioById(id);
    if(!scen){ toast("Scenario not found"); return; }

    state.mode = "editor";
    state.editorScenarioId = id;
    state.editorDraft = JSON.parse(JSON.stringify(scen));
    state.editorDirty = false;
    state.selectedCells.clear();

    state.palette = {};
    for(const a of state.editorDraft.actions){
      state.palette[a] = (a === "Fold") ? 100 : 0;
    }
    state.inspect = { scenarioId: id, hand: null };
    syncModeUI();
    toast("Editor opened (no autosave)");
  }

  function closeEditor(){
    state.editorScenarioId = null;
    state.editorDraft = null;
    state.editorDirty = false;
    state.selectedCells.clear();
  }

  function saveEditorChanges(){
    if(!state.editorDraft) return;
    const idx = state.scenariosAll.findIndex(s => s.id === state.editorDraft.id);
    if(idx >= 0){
      state.editorDraft.updatedAt = nowISO();
      // keep format field
      state.editorDraft.format = state.editorDraft.format || state.format;
      state.editorDraft.tags = state.editorDraft.tags || {};
      state.editorDraft.tags.format = state.editorDraft.format;
      state.scenariosAll[idx] = state.editorDraft;
      saveScenarios();
      state.editorDirty = false;
      toast("Saved");
      renderScenarioList();
      renderEditorLeft();
      renderTopEditorControls();
    }
  }
  function discardEditorChanges(){
    if(!state.editorDraft) return;
    const ok = confirm("Discard unsaved changes?");
    if(!ok) return;
    const original = getScenarioById(state.editorScenarioId);
    if(!original) return;
    state.editorDraft = JSON.parse(JSON.stringify(original));
    state.editorDirty = false;
    state.selectedCells.clear();
    toast("Discarded");
    renderEditorLeft();
    renderEditorMain();
    renderTopEditorControls();
  }

  function renderEditorLeft(){
    leftTitle.textContent = "Editor";
    const scen = state.editorDraft;
    if(!scen){
      leftBody.innerHTML = `<div class="muted">Pick a scenario to edit from the list above.</div>`;
      return;
    }

    const actions = scen.actions;

    leftBody.innerHTML = `
      <div class="row" style="justify-content:space-between;">
        <span class="badge ${state.editorDirty ? "warn":""}">${state.editorDirty ? "Unsaved changes" : "Saved"}</span>
        <span class="tag">Format: <b>${escapeHTML(scen.format || state.format)}</b></span>
      </div>

      <div class="hr"></div>

      <div class="col">
        <div style="font-weight:900;">Scenario name</div>
        <input class="textInput" id="scenNameInput" value="${escapeHTML(scen.name)}" />
        <div class="tiny muted">Changes only persist after Save (Ctrl/⌘+S).</div>
      </div>

      <div class="hr"></div>

      <div class="col">
        <div style="font-weight:900;">Paint palette</div>
        <div class="tiny muted">Drag over cells to paint these action frequencies. Sliders normalize to 100.</div>
      </div>

      <div class="hr"></div>

      <div class="col" id="paletteArea"></div>

      <div class="hr"></div>

      <div class="row">
        <button class="btn primary" id="btnSave" ${state.editorDirty ? "" : "disabled"}>Save (Ctrl/⌘+S)</button>
        <button class="btn" id="btnDiscard" ${state.editorDirty ? "" : "disabled"}>Discard</button>
        <button class="btn" id="btnExportDraft">Export JSON</button>
      </div>

      <div class="hr"></div>

      <div class="tiny muted">Tip: click-drag paints. Press Esc to clear selection.</div>
    `;

    const nameInput = leftBody.querySelector("#scenNameInput");
    nameInput.addEventListener("input", () => {
      state.editorDraft.name = nameInput.value;
      state.editorDirty = true;
      renderTopEditorControls();
      renderEditorLeft(); // enable save
      renderScenarioList();
    });

    const pal = leftBody.querySelector("#paletteArea");
    pal.innerHTML = actions.map(a => {
      const v = Math.round((state.palette[a] ?? 0));
      return `
        <div class="row" style="justify-content:space-between; gap:10px;">
          <span class="tag" style="min-width:120px;"><span class="sw" style="background:${actionColor(a)}"></span>${escapeHTML(a)}</span>
          <input type="range" min="0" max="100" step="1" value="${v}" data-act="${escapeHTML(a)}" style="flex:1" />
          <span class="pill mono" style="min-width:56px; justify-content:center;"><b>${v}%</b></span>
          <button class="btn small" data-100="${escapeHTML(a)}">100%</button>
        </div>
      `;
    }).join("");

    pal.querySelectorAll('input[type="range"][data-act]').forEach(r => {
      r.addEventListener("input", () => {
        const a = r.getAttribute("data-act");
        state.palette[a] = Number(r.value);
        state.palette = normalizePctMap(state.palette, actions);
        state.editorDirty = true;
        renderTopEditorControls();
        renderEditorLeft();
        renderEditorMain();
      });
    });
    pal.querySelectorAll('button[data-100]').forEach(b => {
      b.addEventListener("click", () => {
        const a = b.getAttribute("data-100");
        for(const x of actions) state.palette[x] = 0;
        state.palette[a] = 100;
        state.editorDirty = true;
        renderTopEditorControls();
        renderEditorLeft();
        renderEditorMain();
      });
    });

    leftBody.querySelector("#btnSave").addEventListener("click", saveEditorChanges);
    leftBody.querySelector("#btnDiscard").addEventListener("click", discardEditorChanges);

    leftBody.querySelector("#btnExportDraft").addEventListener("click", () => {
      if(!state.editorDraft) return;
      downloadJSON(state.editorDraft, safeName(state.editorDraft.name) + ".json");
    });
  }

  function renderEditorMain(){
    mainTitle.textContent = "Editor";
    const scen = state.editorDraft;
    scenarioTag.textContent = scen ? scen.name : "—";

    if(!scen){
      mainBody.innerHTML = `<div class="muted">Pick a scenario to edit from the list above.</div>`;
      window.onkeydown = null;
      return;
    }

    mainBody.innerHTML = `
      ${renderInspectorHTML()}
      <div class="hr"></div>
      <div class="panel" style="background:rgba(15,22,33,.55); border:1px solid var(--line); border-radius:14px; padding:12px; height: calc(100vh - 56px - 14px - 14px - 70px - 120px);">
        <div class="row" style="justify-content:space-between; align-items:center;">
          <div>
            <div style="font-weight:900;">Paint the grid</div>
            <div class="tiny muted">No autosave. Save when you’re done.</div>
          </div>
          <div class="row">
            <span class="tag">Selected cells: <b>${state.selectedCells.size}</b></span>
            <button class="btn small" id="btnClearSel">Clear selection</button>
          </div>
        </div>
        <div class="hr"></div>
        <div style="height: calc(100% - 52px);">
          ${renderGridHTML(scen, null, true, { allowClickInspect:true, scenarioId: scen.id })}
        </div>
      </div>
    `;

    const grid = document.getElementById("grid");

    const paintCell = (hand) => {
      const s = state.editorDraft;
      if(!s) return;
      const actions = s.actions;
      const pct = normalizePctMap(state.palette, actions);
      s.grid[hand] = pct;
      state.editorDirty = true;
      state.selectedCells.add(hand);
      const el = grid.querySelector(`[data-hand="${hand}"]`);
      if(el){
        el.style.backgroundImage = buildGradientForCell(pct, actions);
        el.classList.add("sel");
      }
      // also update inspector
      setInspector(s.id, hand);
      renderTopEditorControls();
    };

    const clearSelection = () => {
      state.selectedCells.clear();
      grid.querySelectorAll(".cell.sel").forEach(c => c.classList.remove("sel"));
      toast("Selection cleared");
    };

    document.getElementById("btnClearSel").addEventListener("click", clearSelection);

    state.paintDown = false;
    grid.addEventListener("mousedown", (e) => {
      const cell = e.target.closest(".cell[data-hand]");
      if(!cell) return;
      state.paintDown = true;
      paintCell(cell.getAttribute("data-hand"));
      e.preventDefault();
    });
    grid.addEventListener("mousemove", (e) => {
      if(!state.paintDown) return;
      const cell = e.target.closest(".cell[data-hand]");
      if(!cell) return;
      paintCell(cell.getAttribute("data-hand"));
    });
    window.addEventListener("mouseup", () => state.paintDown = false);

    window.onkeydown = (ev) => {
      if(state.mode !== "editor") return;

      if(ev.key === "Escape"){
        clearSelection();
        return;
      }
      const isSave = (ev.key.toLowerCase() === "s") && (ev.ctrlKey || ev.metaKey);
      if(isSave){
        ev.preventDefault();
        saveEditorChanges();
        return;
      }
    };

    setTimeout(() => fitAllGrids(), 0);
  }

  // Library mode
  function renderLibraryLeft(){
    leftTitle.textContent = "Library";
    leftBody.innerHTML = `
      <div class="row" style="justify-content:space-between;">
        <div class="pill"><span class="muted">Scenarios</span> <b>${getVisibleScenarios().length}</b></div>
        <div class="row">
          <button class="btn small" id="btnNewScenario">New</button>
          <button class="btn small" id="btnExport">Export selected</button>
          <button class="btn small danger" id="btnDelete">Delete selected</button>
        </div>
      </div>
      <div class="hr"></div>
      <div class="tiny muted">
        Import JSON is at the top of the scenario list (this tab). Imported scenarios are assigned to <b>${state.format}</b>.
      </div>
    `;
    leftBody.querySelector("#btnNewScenario").addEventListener("click", () => createNewScenario(true));
    leftBody.querySelector("#btnExport").addEventListener("click", exportSelectedScenarios);
    leftBody.querySelector("#btnDelete").addEventListener("click", deleteSelectedScenarios);
  }

  function renderLibraryMain(){
    mainTitle.textContent = "Library";
    const browseId = getBrowseScenarioId();
    const browseScen = browseId ? getScenarioById(browseId) : null;
    scenarioTag.textContent = browseScen ? browseScen.name : "—";

    if(!browseScen){
      mainBody.innerHTML = `
        ${renderInspectorHTML()}
        <div class="hr"></div>
        <div class="muted">No scenarios in ${state.format}. Import JSON or create a new one.</div>
      `;
      window.onkeydown = null;
      return;
    }

    mainBody.innerHTML = `
      ${renderInspectorHTML()}
      <div class="hr"></div>
      <div class="panel" style="background:rgba(15,22,33,.55); border:1px solid var(--line); border-radius:14px; padding:12px; height: calc(100vh - 56px - 14px - 14px - 70px - 120px);">
        <div class="row" style="justify-content:space-between; align-items:center;">
          <div>
            <div style="font-weight:900;">Browse solution</div>
            <div class="tiny muted">Click a cell to see action % in the inspector.</div>
          </div>
          <div class="row">
            <span class="tag">Actions: <b>${escapeHTML((browseScen.actions||[]).join(", "))}</b></span>
            <button class="btn small" id="btnEditBrowse">Edit</button>
          </div>
        </div>
        <div class="hr"></div>
        <div style="height: calc(100% - 52px);">
          ${renderGridHTML(browseScen, null, false, { allowClickInspect:true, scenarioId:browseScen.id })}
        </div>
      </div>
    `;

    byId("btnEditBrowse").addEventListener("click", () => openEditor(browseScen.id));
    window.onkeydown = null;
    setTimeout(() => fitAllGrids(), 0);
  }

  // Reports
  function renderReportsLeft(){
    leftTitle.textContent = "Reports";
    const reps = loadReports().filter(r => (r.format || "MTT") === state.format);
    leftBody.innerHTML = `
      <div class="row" style="justify-content:space-between;">
        <div class="pill"><span class="muted">Saved sessions</span> <b>${reps.length}</b></div>
        <button class="btn small danger" id="btnClearReports">Clear ${state.format}</button>
      </div>
      <div class="hr"></div>
      <div class="reportList" id="reportList"></div>
      <div class="hr"></div>
      <div class="tiny muted">Reports are stored locally (filtered by format).</div>
    `;
    const list = leftBody.querySelector("#reportList");
    list.innerHTML = reps.slice(0, 30).map(r => {
      const b = r.breakdown || {best:0,correct:0,wrong:0};
      return `
        <div class="report">
          <div class="row" style="justify-content:space-between;">
            <b>${escapeHTML(r.status || "")}</b>
            <span class="badge ${r.avgScore >= 80 ? "good" : (r.avgScore >= 60 ? "warn" : "bad")}">${r.avgScore}%</span>
          </div>
          <div class="tiny muted">${new Date(r.createdAt).toLocaleString()} · ${r.sessionLen} hands</div>
          <div class="tiny muted">Best ${b.best} · Correct ${b.correct} · Wrong ${b.wrong}</div>
        </div>
      `;
    }).join("") || `<div class="muted">No reports yet for ${state.format}.</div>`;

    leftBody.querySelector("#btnClearReports").addEventListener("click", () => {
      if(!confirm(`Delete all ${state.format} reports from this browser?`)) return;
      const all = loadReports();
      const keep = all.filter(r => (r.format || "MTT") !== state.format);
      saveJSON(LS_REP, keep);
      toast("Reports cleared");
      syncModeUI();
    });
  }

  function renderReportsMain(){
    mainTitle.textContent = "Reports";
    scenarioTag.textContent = `Session history (${state.format})`;
    mainBody.innerHTML = `
      <div class="panel" style="background:rgba(15,22,33,.55); border:1px solid var(--line); border-radius:14px; padding:14px;">
        <h2 style="margin:0 0 8px; font-size:18px;">Session reports</h2>
        <div class="muted">Switch format in the top bar to see the other mode’s reports.</div>
      </div>
    `;
    window.onkeydown = null;
  }

  // Resizable left pane
  const divider = document.getElementById("dragDivider");
  let dragging = false;
  divider.addEventListener("mousedown", () => dragging = true);
  window.addEventListener("mouseup", () => dragging = false);
  window.addEventListener("mousemove", (e) => {
    if(!dragging) return;
    const x = e.clientX;
    const min = 280, max = 560;
    const w = Math.min(max, Math.max(min, x));
    document.getElementById("leftPane").style.width = w + "px";
    saveUI();
    setTimeout(() => fitAllGrids(), 0);
  });

  // Global hotkeys for save in editor
  document.addEventListener("keydown", (ev) => {
    const isSave = (ev.key.toLowerCase() === "s") && (ev.ctrlKey || ev.metaKey);
    if(isSave && state.mode === "editor"){
      ev.preventDefault();
      saveEditorChanges();
    }
  });

  // Grid click -> inspector (works outside edit mode too)
  document.addEventListener("click", (ev) => {
    const cell = ev.target.closest(".cell[data-hand][data-sid]");
    if(!cell) return;
    const wrap = cell.closest('[data-gridwrap="1"]');
    if(!wrap) return;
    if(wrap.getAttribute("data-allowinspect") !== "1") return;

    const hand = cell.getAttribute("data-hand");
    const sid = cell.getAttribute("data-sid");
    if(hand && sid){
      setInspector(sid, hand);
    }
  });

  // Remove old trainer text: already removed.

  // Scenario header: selection actions
  byId("btnSelectAll").addEventListener("click", ()=>{});
  byId("btnSelectNone").addEventListener("click", ()=>{});

  // Import / delete / export only as above

  // Editor controls in top bar are rendered by renderTopEditorControls

  // Reset selection etc already handled

  // Reset/initial inspector
  function initInspector(){
    const b = getBrowseScenarioId();
    state.inspect = { scenarioId: b, hand: null };
  }

  // Top-level sync
  function syncAll(){
    initInspector();
    syncModeUI();
  }

  // apply autoplay from URL (play new tab)
  applyAutoplayFromURL();
  syncAll();
  setTimeout(() => fitAllGrids(), 0);

})();
</script>
</body>
</html>
