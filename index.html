<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Preflop Trainer (Browser) – vNext+</title>
  <style>
    :root{
      --bg:#0b0f14;
      --panel:#101824;
      --panel2:#0f1621;
      --text:#e6eef8;
      --muted:#9fb2c7;
      --line:#1d2a3b;
      --accent:#6aa6ff;

      /* GTO-ish colors */
      --fold:#2e6ea6;
      --call:#54b96b;
      --raise:#ff3b3b;
      --raise2:#c62828;
      --jam:#4b0f14;

      --warn:#ffcc66;
      --good:#5ce38a;
      --bad:#ff5c6a;
      --info:#9bd7ff;

      --radius:14px;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:var(--sans);
      background: radial-gradient(1200px 800px at 20% -10%, #172234 0%, var(--bg) 55%) fixed;
      color:var(--text);
      height:100vh;
      overflow:hidden;
    }
    button, input, select{font-family:inherit}
    .topbar{
      height:56px;
      display:flex;
      align-items:center;
      gap:12px;
      padding:10px 14px;
      border-bottom:1px solid var(--line);
      background:rgba(9,13,19,.7);
      backdrop-filter: blur(10px);
    }
    .brand{display:flex;align-items:center;gap:10px;min-width:220px;}
    .dot{
      width:12px;height:12px;border-radius:50%;
      background:linear-gradient(145deg, #6aa6ff, #a06bff);
      box-shadow: 0 0 0 5px rgba(106,166,255,.12);
    }
    .brand strong{letter-spacing:.3px}
    .spacer{flex:1}
    .seg{
      display:inline-flex;
      border:1px solid var(--line);
      border-radius:999px;
      overflow:hidden;
      background:rgba(16,24,36,.8);
    }
    .seg button{
      border:0;
      background:transparent;
      padding:8px 12px;
      color:var(--muted);
      cursor:pointer;
      font-size:13px;
    }
    .seg button.active{
      background:rgba(106,166,255,.18);
      color:var(--text);
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      border:1px solid var(--line);
      background:rgba(16,24,36,.8);
      padding:6px 10px;
      border-radius:999px;
      color:var(--muted);
      font-size:13px;
      white-space:nowrap;
    }
    .pill b{color:var(--text); font-weight:800}
    .btn{
      border:1px solid var(--line);
      background:rgba(16,24,36,.8);
      color:var(--text);
      padding:8px 12px;
      border-radius:12px;
      cursor:pointer;
      transition:transform .05s ease, background .15s ease;
    }
    .btn:hover{background:rgba(22,34,51,.9)}
    .btn:active{transform:translateY(1px)}
    .btn.primary{
      border-color:rgba(106,166,255,.35);
      background:rgba(106,166,255,.18);
    }
    .btn.danger{
      border-color:rgba(255,92,106,.35);
      background:rgba(255,92,106,.12);
    }
    .btn.small{padding:6px 10px; border-radius:10px; font-size:13px}
    .btn:disabled{opacity:.5; cursor:not-allowed}

    .iconBtn{
      width:30px;height:30px;
      display:inline-flex;align-items:center;justify-content:center;
      border:1px solid var(--line);
      background:rgba(16,24,36,.65);
      border-radius:10px;
      cursor:pointer;
      color:var(--muted);
      padding:0;
      user-select:none;
    }
    .iconBtn:hover{filter:brightness(1.1); color:var(--text)}
    .iconBtn:active{transform:translateY(1px)}
    .iconBtn.primary{border-color:rgba(106,166,255,.35); background:rgba(106,166,255,.14)}
    .iconBtn.danger{border-color:rgba(255,92,106,.35); background:rgba(255,92,106,.10)}

    .main{height:calc(100vh - 56px);display:flex;overflow:hidden;}
    .left{
      width:360px;min-width:280px;max-width:560px;
      border-right:1px solid var(--line);
      background:rgba(12,18,27,.68);
      backdrop-filter: blur(10px);
      display:flex;flex-direction:column;overflow:hidden;
    }
    .divider{width:6px;cursor:col-resize;background:transparent;}
    .right{flex:1;display:flex;flex-direction:column;overflow:hidden;padding:14px;gap:14px;}
    .panel{
      border:1px solid var(--line);
      background:rgba(16,24,36,.75);
      border-radius:var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .panelHeader{
      padding:12px 12px 10px;
      border-bottom:1px solid var(--line);
      display:flex;align-items:center;gap:10px;
    }
    .panelHeader h3{margin:0;font-size:14px;letter-spacing:.2px;}
    .panelBody{padding:12px}
    .muted{color:var(--muted)}
    .tiny{font-size:12px}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .col{display:flex;flex-direction:column;gap:8px}
    .hr{height:1px;background:var(--line);margin:10px 0}
    .mono{font-family:var(--mono)}

    .badge{
      padding:5px 10px;border-radius:999px;border:1px solid var(--line);
      font-size:12px;color:var(--muted);background:rgba(0,0,0,.18);
    }
    .badge.good{color:var(--good); border-color: rgba(92,227,138,.25); background:rgba(92,227,138,.08)}
    .badge.bad{color:var(--bad); border-color: rgba(255,92,106,.25); background:rgba(255,92,106,.08)}
    .badge.warn{color:var(--warn); border-color: rgba(255,204,102,.25); background:rgba(255,204,102,.08)}
    .tag{
      display:inline-flex;gap:6px;align-items:center;
      border:1px solid var(--line);padding:4px 8px;border-radius:999px;
      background:rgba(0,0,0,.18);color:var(--muted);font-size:12px;
    }
    .sw{width:10px;height:10px;border-radius:3px;display:inline-block;margin-right:6px;vertical-align:middle}

    /* Scenario list */
    .list{display:flex;flex-direction:column;gap:8px;max-height:360px;overflow:auto;padding-right:6px;}
    .item{
      border:1px solid var(--line);
      background:rgba(15,22,33,.75);
      border-radius:12px;padding:10px;display:flex;flex-direction:column;gap:8px;
    }

    .itemCompact{display:flex;align-items:center;justify-content:space-between;gap:10px;}
    .itemLeft{display:flex;gap:10px;align-items:flex-start;flex:1;min-width:0;}
    .itemName{
      font-size:13px;color:var(--text);line-height:1.25;
      white-space:nowrap;overflow:hidden;text-overflow:ellipsis;
      cursor:pointer;
    }
    .itemName:hover{text-decoration:underline;}
    .itemIcons{display:flex;gap:6px;align-items:center;flex:0 0 auto;}

    .itemTitle{font-size:13px;color:var(--text);line-height:1.25;word-break:break-word;cursor:pointer;}
    .itemTitle:hover{text-decoration:underline;}

    /* Cards */
    .scenarioName{
      font-size:16px;font-weight:900;letter-spacing:.2px;
      margin-top:2px;margin-bottom:4px;color:var(--text);
      text-shadow:0 1px 1px rgba(0,0,0,.4);
    }
    .cards{display:flex;gap:10px;align-items:center;}
    .card{
      width:56px;height:78px;border-radius:12px;
      background:linear-gradient(180deg, #ffffff 0%, #e8eef7 100%);
      color:#111;position:relative;
      box-shadow:0 10px 20px rgba(0,0,0,.35);
      border:1px solid rgba(0,0,0,.15);
      user-select:none;
    }
    .card .r{position:absolute;top:8px;left:8px;font-size:18px;font-weight:900;font-family:var(--mono);}
    .card .s{position:absolute;top:30px;left:9px;font-size:18px;}
    .card .mid{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;font-size:28px;opacity:.9;}
    .redSuit{color:#c5162e}
    .blackSuit{color:#111}

    .rngBanner{
      margin-top:8px;padding:10px 12px;border-radius:14px;
      border:1px solid rgba(255,204,102,.35);
      background:rgba(255,204,102,.08);
      text-align:center;font-weight:900;letter-spacing:.6px;
      color:var(--warn);font-size:22px;font-family:var(--mono);
      text-shadow:0 1px 1px rgba(0,0,0,.35);
      user-select:none;
    }

    .scoreBanner{
      margin-top:10px;
      padding:12px 12px;
      border-radius:14px;
      border:1px solid rgba(106,166,255,.28);
      background:rgba(106,166,255,.10);
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }
    .scoreBanner .big{
      font-size:22px;
      font-weight:950;
      letter-spacing:.4px;
      font-family:var(--mono);
      color:var(--text);
      text-shadow:0 1px 1px rgba(0,0,0,.35);
    }
    .scoreBanner .sub{font-size:12px;color:var(--muted);}

    /* Action buttons */
    .actionBar{display:flex;gap:10px;align-items:stretch;flex-wrap:wrap;}
    .actBtn{
      border:1px solid var(--line);
      background:rgba(15,22,33,.75);
      color:var(--text);
      padding:12px 14px;
      border-radius:14px;
      cursor:pointer;
      min-width:130px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      transition:transform .05s ease, filter .15s ease;
      user-select:none;
    }
    .actBtn:hover{filter:brightness(1.06)}
    .actBtn:active{transform:translateY(1px)}
    .actBtn:disabled{opacity:.55; cursor:not-allowed}

    .k{
      font-size:12px;color:var(--muted);
      border:1px solid var(--line);
      padding:3px 8px;border-radius:999px;
      background:rgba(0,0,0,.22);
      font-family:var(--mono);
    }
    .actFold{background:rgba(46,110,166,.20); border-color:rgba(46,110,166,.35)}
    .actCall{background:rgba(84,185,107,.18); border-color:rgba(84,185,107,.35)}
    .actRaise{background:rgba(255,59,59,.14); border-color:rgba(255,59,59,.35)}
    .actJam{background:rgba(75,15,20,.40); border-color:rgba(170,40,55,.35)}

    /* answer highlighting */
    .hlWrong{outline:2px solid rgba(255,92,106,.95); outline-offset:-2px;}
    .hlCorrect{outline:2px solid rgba(155,215,255,.95); outline-offset:-2px;}
    .hlSolver{box-shadow:0 0 0 3px rgba(255,204,102,.55) inset;}

    /* Grid */
    .gridWrap{display:flex;flex-direction:column;gap:10px;height:100%;overflow:hidden;}
    .grid{
      --cell: 44px;
      display:grid;
      grid-template-columns: repeat(13, var(--cell));
      grid-auto-rows: var(--cell);
      gap:2px;
      background:rgba(0,0,0,.25);
      border:1px solid var(--line);
      border-radius:14px;
      padding:6px;
      overflow:hidden;
      width:100%;
      height:100%;
      justify-content:center;
      align-content:center;
    }
    .grid.small{ --cell: 24px; padding:6px; }
    .cell{
      position:relative;
      border-radius:8px;
      border:1px solid rgba(0,0,0,.15);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:13px;
      font-weight:800;
      color:#f4f7fb;
      text-shadow:0 1px 1px rgba(0,0,0,.55);
      user-select:none;
      cursor:pointer;
      overflow:hidden;
      height: var(--cell);
      width: var(--cell);
      min-width:0;
      min-height:0;
    }
    .grid.small .cell{font-size:10px;border-radius:6px;}
    .cell .lbl{position:relative; z-index:2}
    .cell.sel{outline:2px solid rgba(106,166,255,.9);outline-offset:-2px;}
    .legend{display:flex;gap:10px;flex-wrap:wrap;color:var(--muted);font-size:12px;}

    .toast{
      position:fixed;
      bottom:14px; left:14px;
      background:rgba(16,24,36,.92);
      border:1px solid var(--line);
      padding:10px 12px;
      border-radius:12px;
      box-shadow: var(--shadow);
      color:var(--text);
      font-size:13px;
      opacity:0;
      transform: translateY(8px);
      transition: opacity .2s ease, transform .2s ease;
      pointer-events:none;
      z-index:999;
    }
    .toast.show{opacity:1;transform: translateY(0);}

    .textInput{
      width:100%;
      border:1px solid var(--line);
      background:rgba(10,14,20,.35);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      outline:none;
    }
    .textInput:focus{
      border-color:rgba(106,166,255,.45);
      box-shadow: 0 0 0 4px rgba(106,166,255,.12);
    }

    /* selection strip (cell % display) */
    .selStrip{
      border:1px solid var(--line);
      background:rgba(15,22,33,.55);
      border-radius:14px;
      padding:10px 12px;
    }
    .selStripTop{display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap;}
    .selStripTop b{font-size:13px;}
    .selStripRow{margin-top:8px;display:flex;gap:8px;flex-wrap:wrap;}

    /* reports (pretty) */
    .reportList{
      max-height:300px;
      overflow:auto;
      display:flex;
      flex-direction:column;
      gap:8px;
      padding-right:6px;
    }
    .reportCard{
      border:1px solid var(--line);
      background:rgba(15,22,33,.75);
      border-radius:12px;
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:6px;
      cursor:pointer;
    }
    .reportCard:hover{filter:brightness(1.06)}
    .reportCard.active{outline:2px solid rgba(106,166,255,.75); outline-offset:-2px;}
    .table{
      width:100%;
      border-collapse:separate;
      border-spacing:0;
      overflow:hidden;
      border:1px solid var(--line);
      border-radius:14px;
      background:rgba(15,22,33,.55);
    }
    .table th, .table td{
      padding:10px 10px;
      border-bottom:1px solid rgba(255,255,255,.06);
      font-size:13px;
      vertical-align:top;
    }
    .table th{color:var(--muted); font-weight:800; text-align:left; background:rgba(0,0,0,.12);}
    .trBad{background:rgba(255,92,106,.08);}
    .trWarn{background:rgba(255,204,102,.06);}
    .trGood{background:rgba(155,215,255,.06);}
    .rowClick{cursor:pointer}
    .rowClick:hover{filter:brightness(1.06)}
    .split2{display:grid;grid-template-columns: 1.25fr .85fr; gap:14px; align-items:start;}
    .stickyBox{
      border:1px solid var(--line);
      background:rgba(15,22,33,.55);
      border-radius:14px;
      padding:12px;
    }
    .bigResult{
      text-align:center;
      padding:18px 12px;
      border-radius:16px;
      border:1px solid rgba(106,166,255,.28);
      background:rgba(106,166,255,.10);
    }
    .bigResult .pct{font-size:52px;font-weight:950;font-family:var(--mono);letter-spacing:.8px;}
    .bigResult .title{margin-top:6px;font-size:20px;font-weight:950;}
    .bigResult .subtitle{margin-top:6px;color:var(--muted);font-size:13px;}
    .toggle{display:inline-flex;gap:10px;align-items:center}
    .toggle input{transform:scale(1.1);}

    .actionChip{
      border:1px solid var(--line);
      background:rgba(0,0,0,.18);
      border-radius:999px;
      padding:4px 9px;
      font-size:12px;
      color:var(--muted);
      display:inline-flex;
      align-items:center;
      gap:8px;
      white-space:nowrap;
    }

    .actionManage{
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .actionPills{display:flex;gap:8px;flex-wrap:wrap;}
    .pillX{
      width:18px;height:18px;border-radius:7px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,92,106,.10);
      color:var(--bad);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      font-weight:900;
      user-select:none;
    }
    .pillX:hover{filter:brightness(1.1)}
  
    /* Editor palette numeric input */
    .pctNum{
      width:72px;
      border:1px solid var(--line);
      background:rgba(10,14,20,.35);
      color:var(--text);
      padding:8px 10px;
      border-radius:12px;
      outline:none;
      font-family:var(--mono);
      text-align:center;
    }
    .pctNum:focus{
      border-color:rgba(106,166,255,.45);
      box-shadow: 0 0 0 4px rgba(106,166,255,.12);
    }

    /* Make range sliders feel draggable (thumb) */
    input[type="range"]{ cursor:pointer; }
    input[type="range"]::-webkit-slider-thumb{ cursor:grab; }
    input[type="range"]:active::-webkit-slider-thumb{ cursor:grabbing; }
    input[type="range"]::-moz-range-thumb{ cursor:grab; }
    input[type="range"]:active::-moz-range-thumb{ cursor:grabbing; }

    /* Ensure left pane panels/panel bodies can scroll */
    #leftPane .panelBody{ overflow:auto; }

  
    /* ===== Fix left pane scrolling + panel sizing ===== */
    #leftPane{
      height:100%;
      display:flex;
      flex-direction:column;
      overflow:hidden;
    }
    #leftPane > .panel{
      display:flex;
      flex-direction:column;
      min-height:0;
    }
    /* Keep scenarios panel usable even when editor controls are tall */
    #leftPane > .panel:first-of-type{
      flex:0 0 44%;
      min-height:220px;
    }
    #leftPane > .panel:last-of-type{
      flex:1 1 auto;
      min-height:0;
    }
    #leftPane .panelBody{
      overflow:auto;
      min-height:0;
    }

    /* Slightly wider default left pane so palette buttons fit */
    .left{ width:420px; min-width:300px; }

    /* Palette quick % buttons: smaller + single line */
    .pctBtns{ flex-wrap:nowrap !important; gap:6px !important; }
    .pctBtns .btn.small{
      padding:4px 7px;
      border-radius:10px;
      font-size:12px;
      line-height:1;
    }

  </style>
</head>
<body>
  <div class="topbar">
    <div class="brand">
      <div class="dot"></div>
      <div>
        <strong>Preflop Trainer</strong>
        <div class="tiny muted">Cloudflare Pages · localStorage</div>
      </div>
    </div>

    <div class="seg" id="modeSeg">
      <button data-mode="trainer" class="active">Trainer</button>
      <button data-mode="editor">Editor</button>
      <button data-mode="library">Library</button>
      <button data-mode="reports">Reports</button>
    </div>

    <div class="seg" id="formatSeg" title="MTT and Cash have separate libraries">
      <button data-format="MTT" class="active">MTT</button>
      <button data-format="Cash">Cash</button>
    </div>

    <div class="spacer"></div>

    <div class="row" id="topEditorControls" style="display:none;"></div>

    <button class="btn small" id="btnResetAll">Reset site data</button>
  </div>

  <div class="main">
    <div class="left" id="leftPane">
      <div class="panel" style="margin:14px; margin-bottom:10px;">
        <div class="panelHeader">
          <h3 id="scenarioPanelTitle">Scenarios</h3>
          <div class="spacer"></div>
          <div class="row" id="scenarioHeaderActions"></div>
          <input id="fileImport" type="file" accept=".json" multiple style="display:none" />
        </div>
        <div class="panelBody scrollY">
          <div class="row" style="justify-content:space-between;">
            <div class="pill"><span class="muted">Loaded</span> <b id="scenarioCount">0</b></div>
            <div class="pill"><span class="muted">Selected</span> <b id="scenarioSelectedCount">0</b></div>
          </div>

          <div class="hr"></div>

          <div class="list" id="scenarioList"></div>

          <div class="hr"></div>

          <div class="row">
            <button class="btn small" id="btnSelectAll">Select all</button>
            <button class="btn small" id="btnSelectNone">Select none</button>
          </div>
        </div>
      </div>

      <div class="panel" style="margin:0 14px 14px;">
        <div class="panelHeader">
          <h3 id="leftTitle">Controls</h3>
          <div class="spacer"></div>
          <span class="badge mono" id="hotkeyHint">Hotkeys: X,C,Z,1..9, Enter</span>
        </div>
        <div class="panelBody scrollY" id="leftBody"></div>
      </div>
    </div>

    <div class="divider" id="dragDivider" title="Drag to resize"></div>

    <div class="right">
      <div class="panel">
        <div class="panelHeader">
          <h3 id="mainTitle">Trainer</h3>
          <div class="spacer"></div>
          <span class="tag" id="scenarioTag">—</span>
          <span class="tag" id="formatTag">Format: MTT</span>
        </div>
        <div class="panelBody" id="mainBody" style="height: calc(100vh - 56px - 14px - 14px - 70px);"></div>
      </div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

<script>
(() => {
  /* =========================
     Storage keys (v3)
  ========================= */
  const LS_SCEN = "pokerTrainerScenarios_v3";
  const LS_REP  = "pokerTrainerReports_v3";
  const LS_UI   = "pokerTrainerUI_v3";

  const RANKS = "AKQJT98765432";

  /* =========================
     DOM refs
  ========================= */
  const modeSeg = document.getElementById("modeSeg");
  const formatSeg = document.getElementById("formatSeg");
  const leftTitle = document.getElementById("leftTitle");
  const leftBody  = document.getElementById("leftBody");
  const mainTitle = document.getElementById("mainTitle");
  const mainBody  = document.getElementById("mainBody");
  const scenarioList = document.getElementById("scenarioList");
  const scenarioCount = document.getElementById("scenarioCount");
  const scenarioSelectedCount = document.getElementById("scenarioSelectedCount");
  const scenarioTag = document.getElementById("scenarioTag");
  const formatTag = document.getElementById("formatTag");

  const scenarioHeaderActions = document.getElementById("scenarioHeaderActions");
  const scenarioPanelTitle = document.getElementById("scenarioPanelTitle");
  const fileImport = document.getElementById("fileImport");
  const topEditorControls = document.getElementById("topEditorControls");

  /* =========================
     Utils
  ========================= */
  function toast(msg){
    const el = document.getElementById("toast");
    el.textContent = msg;
    el.classList.add("show");
    setTimeout(() => el.classList.remove("show"), 1800);
  }
  function nowISO(){ return new Date().toISOString(); }
  function loadJSON(key, fallback){
    try{
      const s = localStorage.getItem(key);
      if(!s) return fallback;
      return JSON.parse(s);
    }catch{ return fallback; }
  }
  function saveJSON(key, val){ localStorage.setItem(key, JSON.stringify(val)); }
  function escapeHTML(s){
    return String(s).replace(/[&<>"']/g, (c) => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
    }[c]));
  }
  function safeName(s){
    return String(s).replace(/[^A-Za-z0-9._-]+/g, "_").slice(0, 160);
  }
  function downloadJSON(obj, filename){
    const blob = new Blob([JSON.stringify(obj, null, 2)], {type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    URL.revokeObjectURL(a.href);
    a.remove();
  }
  function getCSS(varName){
    return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
  }
  function byId(id){ return document.getElementById(id); }

  /* =========================
     Grid fit
  ========================= */
  function fitAllGrids(){
    document.querySelectorAll(".grid").forEach(g => fitGrid(g));
  }
  function fitGrid(gridEl){
    if(!gridEl) return;
    if(gridEl.classList.contains("small")) return; // fixed
    const rect = gridEl.getBoundingClientRect();
    if(rect.width < 60 || rect.height < 60) return;

    const cs = getComputedStyle(gridEl);
    const gap = parseFloat(cs.gap || cs.columnGap || "2") || 2;
    const padL = parseFloat(cs.paddingLeft || "6") || 6;
    const padR = parseFloat(cs.paddingRight || "6") || 6;
    const padT = parseFloat(cs.paddingTop || "6") || 6;
    const padB = parseFloat(cs.paddingBottom || "6") || 6;

    const availW = rect.width - padL - padR - gap * 12;
    const availH = rect.height - padT - padB - gap * 12;

    const cellW = Math.floor(availW / 13);
    const cellH = Math.floor(availH / 13);

    let cell = Math.min(cellW, cellH);
    cell = Math.max(22, Math.min(48, cell));
    gridEl.style.setProperty("--cell", cell + "px");
  }
  let resizeT=null;
  window.addEventListener("resize", () => {
    clearTimeout(resizeT);
    resizeT = setTimeout(() => fitAllGrids(), 60);
  });

  /* =========================
     Scenario normalization + migration
  ========================= */
  function normalizeScenario(raw, assignFormat){
    if(!raw || typeof raw !== "object") throw new Error("Invalid JSON");
    const name = String(raw.name ?? raw.scenarioName ?? raw.title ?? "Unnamed Scenario");
    const tags = (raw.tags && typeof raw.tags==="object") ? raw.tags : {};
    const grid = raw.grid && typeof raw.grid==="object" ? raw.grid : null;
    if(!grid) throw new Error("Scenario missing grid");

    let actions = Array.isArray(raw.actions) ? raw.actions.map(String) : null;
    if(!actions){
      const anyHand = Object.keys(grid)[0];
      if(!anyHand) throw new Error("Empty grid");
      actions = Object.keys(grid[anyHand] || {}).map(String);
    }
    if(!actions.includes("Fold")) actions.unshift("Fold");

    // Keep only known keys, fill missing
    for(const hand of Object.keys(grid)){
      const obj = grid[hand] || {};
      for(const a of actions){
        if(obj[a] == null) obj[a] = 0;
      }
      for(const k of Object.keys(obj)){
        if(!actions.includes(k)) delete obj[k];
      }
      grid[hand] = obj;
    }

    const format = String(raw.format || tags.format || assignFormat || "MTT");
    const fmt = (format === "Cash") ? "Cash" : "MTT";
    return {
      id: raw.id || crypto.randomUUID(),
      name,
      actions,
      tags: {...tags, format: fmt},
      format: fmt,
      grid,
      created: raw.created || "import",
      updatedAt: nowISO(),
    };
  }

  function migrateOlderIfNeeded(){
    // If v3 exists, do nothing
    if(localStorage.getItem(LS_SCEN)) return;

    // Try from v2, v1 keys
    const tryKeys = ["pokerTrainerScenarios_v2","pokerTrainerScenarios_v1"];
    for(const k of tryKeys){
      const s = localStorage.getItem(k);
      if(!s) continue;
      try{
        const arr = JSON.parse(s);
        if(Array.isArray(arr)){
          const converted = arr.map(sc => normalizeScenario(sc, sc.format || sc.tags?.format || "MTT"));
          saveJSON(LS_SCEN, converted);
          break;
        }
      }catch{}
    }

    // Reports
    if(!localStorage.getItem(LS_REP)){
      const r2 = localStorage.getItem("pokerTrainerReports_v2") || localStorage.getItem("pokerTrainerReports_v1");
      if(r2){
        try{ saveJSON(LS_REP, JSON.parse(r2)); }catch{}
      }
    }
    // UI
    if(!localStorage.getItem(LS_UI)){
      const u2 = localStorage.getItem("pokerTrainerUI_v2") || localStorage.getItem("pokerTrainerUI_v1");
      if(u2){
        try{ saveJSON(LS_UI, JSON.parse(u2)); }catch{}
      }
    }
  }

  /* =========================
     State
  ========================= */
  const state = {
    mode: "trainer",
    format: "MTT",

    scenariosAll: [],

    selectedIdsByFormat: { MTT: new Set(), Cash: new Set() },
    browseScenarioIdByFormat: { MTT: null, Cash: null },

    // cell selection display
    selection: { scenarioId: null, hand: null },

    // trainer
    sessionLen: 20,
    sessionActive: false,
    sessionQueue: [],
    currentIdx: 0,
    currentHand: null,
    reveal: false,
    attempts: [],
    lastTierClass: "",
    lastUserAction: null,
    showGridAfterAnswer: true,
    trainerResults: null,          // {reportId, reportObj, config}
    lastSessionConfig: null,       // persisted for restart on results screen
    lastSessionScore: 0,

    // reports
    reportSelectedId: null,
    reportFilter: "all",           // all | wrong | correct | best
    reportSort: "errors",          // errors | time | pts | scenario
    reportSelectedAttemptIdx: null,

    // editor
    editorScenarioId: null,
    editorDraft: null,
    editorDirty: false,
    paintDown: false,
    selectedCells: new Set(),
    palette: {},
  };

  /* =========================
     UI persistence
  ========================= */
  function loadUI(){
    const ui = loadJSON(LS_UI, null);
    if(ui && typeof ui === "object"){
      if(ui.leftWidth) document.getElementById("leftPane").style.width = ui.leftWidth + "px";
      if(ui.format === "MTT" || ui.format === "Cash") state.format = ui.format;

      if(ui.selectedIdsByFormat){
        for(const fmt of ["MTT","Cash"]){
          const arr = ui.selectedIdsByFormat[fmt];
          if(Array.isArray(arr)) state.selectedIdsByFormat[fmt] = new Set(arr);
        }
      }
      if(ui.browseScenarioIdByFormat){
        for(const fmt of ["MTT","Cash"]){
          const id = ui.browseScenarioIdByFormat[fmt];
          if(typeof id === "string") state.browseScenarioIdByFormat[fmt] = id;
        }
      }
      if(typeof ui.sessionLen === "number") state.sessionLen = ui.sessionLen;
      if(typeof ui.showGridAfterAnswer === "boolean") state.showGridAfterAnswer = ui.showGridAfterAnswer;
    }
  }
  function saveUI(){
    saveJSON(LS_UI, {
      leftWidth: parseInt(document.getElementById("leftPane").style.width || "360", 10),
      format: state.format,
      selectedIdsByFormat: {
        MTT: [...state.selectedIdsByFormat.MTT],
        Cash: [...state.selectedIdsByFormat.Cash],
      },
      browseScenarioIdByFormat: state.browseScenarioIdByFormat,
      sessionLen: state.sessionLen,
      showGridAfterAnswer: state.showGridAfterAnswer,
    });
  }

  /* =========================
     Scenarios
  ========================= */
  function loadScenarios(){
    const arr = loadJSON(LS_SCEN, []);
    state.scenariosAll = Array.isArray(arr) ? arr : [];
    for(const s of state.scenariosAll){
      if(!s.id) s.id = crypto.randomUUID();
      const fmt = s.format || s.tags?.format || "MTT";
      s.format = (fmt === "Cash") ? "Cash" : "MTT";
      s.tags = s.tags || {};
      s.tags.format = s.format;
      s.actions = Array.isArray(s.actions) ? s.actions : ["Fold"];
      if(!s.actions.includes("Fold")) s.actions.unshift("Fold");
      s.grid = s.grid || {};
    }
    // default select all per format
    for(const fmt of ["MTT","Cash"]){
      if(state.selectedIdsByFormat[fmt].size === 0){
        state.scenariosAll.filter(s => s.format === fmt).forEach(s => state.selectedIdsByFormat[fmt].add(s.id));
      }
      if(!state.browseScenarioIdByFormat[fmt]){
        const first = state.scenariosAll.find(s => s.format === fmt);
        state.browseScenarioIdByFormat[fmt] = first ? first.id : null;
      }
    }
  }
  function saveScenarios(){
    saveJSON(LS_SCEN, state.scenariosAll);
    saveUI();
  }
  function getScenarioById(id){ return state.scenariosAll.find(s => s.id === id) || null; }
  function getVisibleScenarios(){ return state.scenariosAll.filter(s => s.format === state.format); }
  function getSelectedSet(){ return state.selectedIdsByFormat[state.format]; }
  function setSelectedSet(newSet){ state.selectedIdsByFormat[state.format] = newSet; saveUI(); }
  function getBrowseScenarioId(){ return state.browseScenarioIdByFormat[state.format]; }
  function setBrowseScenarioId(id){ state.browseScenarioIdByFormat[state.format] = id; saveUI(); }

  /* =========================
     Reports
  ========================= */
  function loadReports(){
    const arr = loadJSON(LS_REP, []);
    return Array.isArray(arr) ? arr : [];
  }
  function saveReports(arr){
    saveJSON(LS_REP, arr);
  }
  function addReport(report){
    const arr = loadReports();
    arr.unshift(report);
    saveReports(arr.slice(0, 250));
  }

  /* =========================
     Colors / action ordering
  ========================= */
  function actionColor(action){
    const a = String(action).toLowerCase();
    if(a === "fold") return getCSS("--fold");
    if(a === "call") return getCSS("--call");
    if(a === "jam" || a === "allin" || a === "all-in") return getCSS("--jam");
    if(a.startsWith("raise")){
      const m = a.match(/raise\s*(\d+)/i);
      if(m){
        const n = parseInt(m[1], 10);
        return n <= 1 ? getCSS("--raise") : getCSS("--raise2");
      }
      return getCSS("--raise");
    }
    return "#777";
  }

  function sortRaisesSmallToLarge(raises){
    const key = (a)=>{
      const m = String(a).toLowerCase().match(/raise\s*(\d+)/i);
      if(m) return parseInt(m[1],10);
      return 1;
    };
    return [...raises].sort((a,b)=>key(a)-key(b));
  }

  // Aggressive -> passive (for left->right in cell)
  function aggressionOrder(actions){
    const raises = actions.filter(a => String(a).toLowerCase().startsWith("raise"));
    const jam = actions.filter(a => String(a).toLowerCase() === "jam");
    const call = actions.filter(a => String(a).toLowerCase() === "call");
    const fold = actions.filter(a => String(a).toLowerCase() === "fold");
    const raiseKey = (a) => {
      const m = String(a).toLowerCase().match(/raise\s*(\d+)/);
      if(m) return parseInt(m[1],10);
      return 1;
    };
    // larger raise more aggressive
    raises.sort((a,b) => raiseKey(b) - raiseKey(a));
    return [...jam, ...raises, ...call, ...fold];
  }

  function numberedAggroActions(scenario){
    const raises = sortRaisesSmallToLarge(scenario.actions.filter(a => String(a).toLowerCase().startsWith("raise")));
    const out = [...raises];
    if(scenario.actions.some(a => String(a).toLowerCase() === "jam")) out.push("Jam");
    return out;
  }

  function normalizePctMap(map, actions){
    let sum = 0;
    const out = {};
    for(const a of actions){
      let v = Number(map[a] ?? 0);
      if(!Number.isFinite(v)) v = 0;
      v = Math.max(0, v);
      out[a] = v;
      sum += v;
    }
    if(sum <= 0){
      out["Fold"] = 100;
      for(const a of actions){
        if(a !== "Fold") out[a] = 0;
      }
      return out;
    }
    for(const a of actions){
      out[a] = (out[a] * 100) / sum;
    }
    let sum2 = 0, maxA = actions[0], maxV = -1;
    for(const a of actions){
      sum2 += out[a];
      if(out[a] > maxV){ maxV = out[a]; maxA = a; }
    }
    out[maxA] += (100 - sum2);
    return out;
  }

  function buildGradientForCell(pctMap, actions){
    const order = aggressionOrder(actions); // aggressive left
    const norm = normalizePctMap(pctMap || {}, actions);
    const parts = [];
    let start = 0;
    for(const a of order){
      const v = Math.max(0, Number(norm[a] ?? 0));
      if(v <= 0.001) continue;
      const end = start + v;
      const col = actionColor(a);
      parts.push(`${col} ${start.toFixed(2)}% ${end.toFixed(2)}%`);
      start = end;
    }
    if(parts.length === 0){
      return `linear-gradient(to right, ${getCSS("--panel2")} 0% 100%)`;
    }
    if(start < 100){
      parts.push(`${getCSS("--panel2")} ${start.toFixed(2)}% 100%`);
    }
    return `linear-gradient(to right, ${parts.join(", ")})`;
  }

  /* =========================
     169 combos
  ========================= */
  function labelFromRC(r,c){
    const hi = RANKS[Math.min(r,c)];
    const lo = RANKS[Math.max(r,c)];
    if(r===c) return hi+lo;
    return r < c ? `${hi}${lo}s` : `${hi}${lo}o`;
  }
  function allComboLabels(){
    const out=[];
    for(let r=0;r<13;r++){
      for(let c=0;c<13;c++){
        out.push(labelFromRC(r,c));
      }
    }
    return out;
  }
  const ALL_LABELS = allComboLabels();
  function randomHandLabel(){ return ALL_LABELS[Math.floor(Math.random()*ALL_LABELS.length)]; }

  /* =========================
     Cards
  ========================= */
  const suits = [
    {s:"♠", cls:"blackSuit"}, {s:"♥", cls:"redSuit"},
    {s:"♦", cls:"redSuit"},   {s:"♣", cls:"blackSuit"},
  ];
  function handToTwoCards(hand){
    const r1 = hand[0], r2 = hand[1];
    const suited = hand.length === 3 && hand[2] === "s";
    let s1, s2;
    if(r1 === r2){
      s1 = suits[Math.floor(Math.random()*4)];
      do { s2 = suits[Math.floor(Math.random()*4)]; } while(s2.s === s1.s);
    }else if(suited){
      s1 = suits[Math.floor(Math.random()*4)];
      s2 = s1;
    }else{
      s1 = suits[Math.floor(Math.random()*4)];
      do { s2 = suits[Math.floor(Math.random()*4)]; } while(s2.s === s1.s);
    }
    return [
      {rank:r1, suit:s1.s, cls:s1.cls},
      {rank:r2, suit:s2.s, cls:s2.cls},
    ];
  }
  function renderCardHTML(c){
    return `
      <div class="card">
        <div class="r ${c.cls}">${c.rank}</div>
        <div class="s ${c.cls}">${c.suit}</div>
        <div class="mid ${c.cls}">${c.suit}</div>
      </div>
    `;
  }

  /* =========================
     RNG selection + scoring
  ========================= */
  function pickSolverAction(pctMap, actions){
    const order = aggressionOrder(actions);
    const norm = normalizePctMap(pctMap, actions);
    const rng = Math.floor(Math.random()*100) + 1;
    let cum = 0;
    let choice = order[order.length-1] || "Fold";
    for(const a of order){
      cum += Math.max(0, Number(norm[a] ?? 0));
      if(rng <= cum){
        choice = a;
        break;
      }
    }
    return {rng, choice, normalized: norm};
  }
  function scoreAttempt(userAction, solverChoice, pctMap, actions){
    const norm = normalizePctMap(pctMap, actions);
    const used = Number(norm[userAction] ?? 0) > 0.0001;
    if(userAction === solverChoice) return {tier:"best", pts:100};
    if(used) return {tier:"correct", pts:70};
    return {tier:"wrong", pts:0};
  }

  /* =========================
     Selection strip (cell % display)
  ========================= */
  function setSelection(scenarioId, hand){
    state.selection = { scenarioId, hand };
    // In editor we still want to keep editor UI; in other modes this updates display
    renderMain();
  }
  function renderSelectionStripHTML(opts){
    const compact = !!(opts && opts.compact);
    const sel = state.selection;
    const s = sel.scenarioId ? getScenarioById(sel.scenarioId) : null;

    if(!s){
      return compact ? "" : `
        <div class="selStrip">
          <div class="selStripTop"><b>Selected</b><span class="tag mono">—</span></div>
        </div>
      `;
    }
    const hand = sel.hand;
    const title = hand ? `<span class="tag mono">${escapeHTML(hand)}</span>` : `<span class="tag mono">—</span>`;
    const body = hand ? (() => {
      const pct = s.grid?.[hand] || {};
      const norm = normalizePctMap(pct, s.actions);
      return `
        <div class="selStripRow">
          ${s.actions.map(a => {
            const v = Math.round((norm[a]||0)*10)/10;
            return `<span class="tag"><span class="sw" style="background:${actionColor(a)}"></span>${escapeHTML(a)}: <b>${v}%</b></span>`;
          }).join("")}
        </div>
      `;
    })() : "";

    return `
      <div class="selStrip">
        <div class="selStripTop">
          <b>Selected</b>
          <div class="row" style="gap:8px;">
            ${title}
            <span class="tag">${escapeHTML(s.name)}</span>
          </div>
        </div>
        ${body}
      </div>
    `;
  }

  /* =========================
     Grid renderer
  ========================= */
  function renderGridHTML(scenario, highlightHand, opts){
    const actions = scenario.actions;
    const allowClick = !!(opts && opts.allowClickSelect);
    const sid = (opts && opts.scenarioId) ? opts.scenarioId : scenario.id;
    const isSmall = !!(opts && opts.small);

    const cells = [];
    for(let r=0;r<13;r++){
      for(let c=0;c<13;c++){
        const hand = labelFromRC(r,c);
        const pctMap = scenario.grid[hand] || {};
        const grad = buildGradientForCell(pctMap, actions);
        const isHL = hand === highlightHand;
        const isSel = (state.selection.scenarioId === sid && state.selection.hand === hand);
        const cls = `cell ${isSel ? "sel":""}`;
        cells.push(`
          <div class="${cls}" data-hand="${hand}" data-sid="${sid}" data-clickselect="${allowClick ? "1":"0"}"
               style="background-image:${grad}; ${isHL ? "outline:2px solid rgba(255,204,102,.9); outline-offset:-2px;" : ""}">
            <div class="lbl mono">${hand}</div>
          </div>
        `);
      }
    }

    // Legend is useful but keep tight; show only when not small
    const legend = isSmall ? "" : `
      <div class="legend">
        ${aggressionOrder(actions).map(a => `<span><span class="sw" style="background:${actionColor(a)}"></span>${escapeHTML(a)}</span>`).join("")}
      </div>
    `;

    return `
      <div class="gridWrap">
        ${legend}
        <div class="grid ${isSmall ? "small":""}" id="grid">${cells.join("")}</div>
      </div>
    `;
  }

  /* =========================
     Action management (Editor)
  ========================= */
  function getActionCounts(actions){
    const hasCall = actions.some(a => String(a).toLowerCase() === "call");
    const hasJam = actions.some(a => String(a).toLowerCase() === "jam");
    const raises = actions.filter(a => String(a).toLowerCase().startsWith("raise"));
    const nRaises = raises.length;
    return {hasCall, hasJam, nRaises};
  }

  function canonicalActionsFromParts(hasCall, nRaises, hasJam){
    const out = ["Fold"];
    if(hasCall) out.push("Call");
    for(let i=1;i<=nRaises;i++) out.push(`Raise ${i}`);
    if(hasJam) out.push("Jam");
    return out;
  }

  function renameRaiseKey(key, newIndex){
    return `Raise ${newIndex}`;
  }

  function rebuildScenarioActions(scen, hasCall, nRaises, hasJam){
    const oldActions = scen.actions.slice();
    const newActions = canonicalActionsFromParts(hasCall, nRaises, hasJam);

    // Build mapping for raise renumbering
    const oldRaises = sortRaisesSmallToLarge(oldActions.filter(a => String(a).toLowerCase().startsWith("raise")));
    const newRaises = [];
    for(let i=1;i<=nRaises;i++) newRaises.push(`Raise ${i}`);

    // map old raise keys in order to new raise keys (truncate or expand)
    const raiseMap = new Map();
    for(let i=0;i<Math.min(oldRaises.length, newRaises.length);i++){
      raiseMap.set(oldRaises[i], newRaises[i]);
    }

    // transform each hand map
    for(const hand of ALL_LABELS){
      const oldMap = scen.grid[hand] || {};
      const newMap = {};
      for(const a of newActions){
        newMap[a] = 0;
      }

      // carry over Fold / Call / Jam directly if present, raise via mapping
      for(const a of oldActions){
        if(a === "Fold" && newMap["Fold"] != null) newMap["Fold"] += Number(oldMap[a]||0);
        else if(a === "Call" && newMap["Call"] != null) newMap["Call"] += Number(oldMap[a]||0);
        else if(a === "Jam" && newMap["Jam"] != null) newMap["Jam"] += Number(oldMap[a]||0);
        else if(String(a).toLowerCase().startsWith("raise")){
          const mapped = raiseMap.get(a);
          if(mapped && newMap[mapped] != null) newMap[mapped] += Number(oldMap[a]||0);
        }
      }

      // If some removed actions existed, redistribute proportionally via normalize
      const norm = normalizePctMap(newMap, newActions);
      scen.grid[hand] = norm;
    }

    scen.actions = newActions;
    return scen;
  }

  /* =========================
     Create new scenario
  ========================= */
  function emptyGridForActions(actions){
    const grid = {};
    for(const hand of ALL_LABELS){
      const obj = {};
      for(const a of actions) obj[a] = 0;
      obj["Fold"] = 100;
      grid[hand] = obj;
    }
    return grid;
  }

  function createNewScenario(openEditorAfter=true){
    const name = (prompt(`Scenario name (saved under ${state.format})`) || "").trim();
    if(!name) return;

    const includeCall = (prompt("Include Call/Limp? (y/n)", "n") || "n").trim().toLowerCase().startsWith("y");
    const raiseCountRaw = (prompt("How many non-jam raise sizes? (0-6)", "1") || "1").trim();
    let raiseCount = parseInt(raiseCountRaw, 10);
    if(!Number.isFinite(raiseCount) || raiseCount < 0) raiseCount = 0;
    if(raiseCount > 6) raiseCount = 6;
    const includeJam = (prompt("Include Jam (all-in)? (y/n)", "y") || "y").trim().toLowerCase().startsWith("y");

    const actions = canonicalActionsFromParts(includeCall, raiseCount, includeJam);

    const scen = {
      id: crypto.randomUUID(),
      name,
      actions,
      tags: { format: state.format },
      format: state.format,
      grid: emptyGridForActions(actions),
      created: "local",
      updatedAt: nowISO(),
    };

    state.scenariosAll.push(scen);
    const set = new Set([...getSelectedSet()]);
    set.add(scen.id);
    setSelectedSet(set);
    setBrowseScenarioId(scen.id);

    saveScenarios();
    renderScenarioList();
    toast("Created");
    if(openEditorAfter) openEditor(scen.id);
  }

  /* =========================
     Import / export / delete
  ========================= */
  fileImport.addEventListener("change", async (e) => {
    const files = Array.from(e.target.files || []);
    if(!files.length) return;

    let added = 0;
    for(const f of files){
      try{
        const text = await f.text();
        const raw = JSON.parse(text);
        const scen = normalizeScenario(raw, state.format);

        const idx = state.scenariosAll.findIndex(s => s.format === scen.format && s.name === scen.name);
        if(idx >= 0){
          scen.id = state.scenariosAll[idx].id;
          state.scenariosAll[idx] = scen;
        }else{
          state.scenariosAll.push(scen);
        }

        const set = new Set([...state.selectedIdsByFormat[scen.format]]);
        set.add(scen.id);
        state.selectedIdsByFormat[scen.format] = set;

        if(scen.format === state.format) setBrowseScenarioId(scen.id);
        added++;
      }catch(err){
        console.error(err);
        toast(`Failed: ${f.name}`);
      }
    }
    saveScenarios();
    renderScenarioList();
    renderLeft();
    renderMain();
    toast(`Imported ${added}`);
    e.target.value = "";
  });

  function exportSelectedScenarios(){
    const selectedSet = getSelectedSet();
    const list = getVisibleScenarios().filter(s => selectedSet.has(s.id));
    if(list.length === 0) return toast("Nothing selected");
    if(list.length === 1){
      downloadJSON(list[0], safeName(list[0].name) + ".json");
    }else{
      list.forEach((sc, i) => setTimeout(() => downloadJSON(sc, safeName(sc.name)+".json"), i*120));
      toast(`Downloading ${list.length} files...`);
    }
  }

  function deleteSelectedScenarios(){
    const selectedSet = getSelectedSet();
    const ids = [...selectedSet];
    if(!ids.length) return toast("Nothing selected");
    if(!confirm(`Delete ${ids.length} selected from ${state.format} (this browser)?`)) return;

    state.scenariosAll = state.scenariosAll.filter(s => !(s.format === state.format && selectedSet.has(s.id)));
    const remain = getVisibleScenarios();
    setSelectedSet(new Set(remain.map(s => s.id)));

    const b = getBrowseScenarioId();
    const stillExists = b && getScenarioById(b) && getScenarioById(b).format === state.format;
    if(!stillExists) setBrowseScenarioId(remain[0]?.id || null);

    if(state.editorScenarioId && !getScenarioById(state.editorScenarioId)) closeEditor();

    saveScenarios();
    renderScenarioList();
    toast("Deleted");
    renderMain();
  }

  byId("btnSelectAll").addEventListener("click", () => {
    setSelectedSet(new Set(getVisibleScenarios().map(s => s.id)));
    renderScenarioList();
  });
  byId("btnSelectNone").addEventListener("click", () => {
    setSelectedSet(new Set());
    renderScenarioList();
  });

  /* =========================
     Scenario list
  ========================= */
  function renderScenarioHeaderActions(){
    scenarioHeaderActions.innerHTML = "";

    const mkBtn = (label, cls, onClick) => {
      const b = document.createElement("button");
      b.className = `btn small ${cls||""}`.trim();
      b.textContent = label;
      b.addEventListener("click", onClick);
      return b;
    };

    if(state.mode === "library"){
      const importBtn = document.createElement("button");
      importBtn.className = "btn small";
      importBtn.textContent = "Import JSON";
      importBtn.addEventListener("click", ()=> fileImport.click());
      scenarioHeaderActions.appendChild(importBtn);
      scenarioHeaderActions.appendChild(mkBtn("New", "primary", () => createNewScenario(true)));
      scenarioHeaderActions.appendChild(mkBtn("Export", "", exportSelectedScenarios));
      scenarioHeaderActions.appendChild(mkBtn("Delete", "danger", deleteSelectedScenarios));
    } else if(state.mode === "trainer"){
      scenarioHeaderActions.appendChild(mkBtn("New", "primary", () => createNewScenario(true)));
    } else if(state.mode === "editor"){
      scenarioHeaderActions.appendChild(mkBtn("New", "primary", () => createNewScenario(true)));
    } else if(state.mode === "reports"){
      // nothing
    }

    scenarioPanelTitle.textContent = `Scenarios (${state.format})`;
  }

  function renderScenarioList(){
    scenarioList.innerHTML = "";
    const visible = getVisibleScenarios();
    const selectedSet = getSelectedSet();
    scenarioCount.textContent = String(visible.length);
    scenarioSelectedCount.textContent = String(selectedSet.size);

    const sorted = [...visible].sort((a,b) => (a.name||"").localeCompare(b.name||""));
    const compact = (state.mode === "trainer");

    for(const s of sorted){
      const checked = selectedSet.has(s.id);
      const el = document.createElement("div");
      el.className = "item";

      if(compact){
        el.innerHTML = `
          <div class="itemCompact">
            <div class="itemLeft">
              <input type="checkbox" ${checked ? "checked":""} data-id="${s.id}" />
              <div class="itemName" title="${escapeHTML(s.name)}" data-browse="${s.id}">
                ${escapeHTML(s.name)}
              </div>
            </div>
            <div class="itemIcons">
              <button class="iconBtn primary" title="Play (Ctrl/Cmd/Shift = new tab)" data-play="${s.id}">▶</button>
              <button class="iconBtn" title="Edit" data-edit="${s.id}">✎</button>
            </div>
          </div>
        `;
      } else {
        el.innerHTML = `
          <div style="display:flex;align-items:flex-start;justify-content:space-between;gap:10px;">
            <div style="display:flex;gap:10px;align-items:flex-start;">
              <input type="checkbox" ${checked ? "checked":""} data-id="${s.id}" />
              <div>
                <div class="itemTitle" data-browse="${s.id}">${escapeHTML(s.name)}</div>
                <div class="row" style="margin-top:8px;">
                  <span class="tag">Actions: <b>${escapeHTML((s.actions||[]).join(", "))}</b></span>
                  <span class="tag">Format: <b>${escapeHTML(s.format)}</b></span>
                </div>
              </div>
            </div>
            <div class="row" style="gap:8px;">
              <button class="iconBtn" title="Edit" data-edit="${s.id}">✎</button>
            </div>
          </div>
        `;
      }
      scenarioList.appendChild(el);
    }

    scenarioList.querySelectorAll('input[type="checkbox"][data-id]').forEach(cb => {
      cb.addEventListener("change", (e) => {
        const id = e.target.getAttribute("data-id");
        const set = new Set([...getSelectedSet()]);
        if(e.target.checked) set.add(id);
        else set.delete(id);
        setSelectedSet(set);
        scenarioSelectedCount.textContent = String(set.size);
      });
    });

    scenarioList.querySelectorAll('[data-edit]').forEach(btn => {
      btn.addEventListener("click", () => openEditor(btn.getAttribute("data-edit")));
    });

    scenarioList.querySelectorAll('[data-browse]').forEach(btn => {
      btn.addEventListener("click", () => {
        const id = btn.getAttribute("data-browse");
        setBrowseScenarioId(id);
        state.selection = {scenarioId:id, hand:null};
        // leaving results screen if any
        if(state.mode === "trainer" && state.trainerResults) state.trainerResults = null;
        renderMain();
      });
    });

    scenarioList.querySelectorAll('[data-play]').forEach(btn => {
      btn.addEventListener("click", (ev) => {
        const id = btn.getAttribute("data-play");
        if(ev.ctrlKey || ev.metaKey || ev.shiftKey){
          const u = new URL(window.location.href);
          u.searchParams.set("mode","trainer");
          u.searchParams.set("format", state.format);
          u.searchParams.set("play", id);
          window.open(u.toString(), "_blank");
          return;
        }
        setBrowseScenarioId(id);
        setSelectedSet(new Set([id]));
        state.mode = "trainer";
        syncModeUI();
        renderMain();
        startSessionForScenarioId(id);
      });
    });
  }

  /* =========================
     Editor
  ========================= */
  function openEditor(id){
    const scen = getScenarioById(id);
    if(!scen){ toast("Not found"); return; }

    state.mode = "editor";
    state.editorScenarioId = id;
    state.editorDraft = JSON.parse(JSON.stringify(scen));
    state.editorDirty = false;
    state.selectedCells.clear();

    state.palette = {};
    for(const a of state.editorDraft.actions){
      state.palette[a] = (a === "Fold") ? 100 : 0;
    }

    state.selection = {scenarioId:id, hand:null};
    syncModeUI();
    toast("Editor opened");
  }
  function closeEditor(){
    state.editorScenarioId = null;
    state.editorDraft = null;
    state.editorDirty = false;
    state.selectedCells.clear();
  }

  function saveEditorChanges(){
    if(!state.editorDraft) return;
    const idx = state.scenariosAll.findIndex(s => s.id === state.editorDraft.id);
    if(idx >= 0){
      state.editorDraft.updatedAt = nowISO();
      state.editorDraft.format = state.editorDraft.format || state.format;
      state.editorDraft.tags = state.editorDraft.tags || {};
      state.editorDraft.tags.format = state.editorDraft.format;
      state.scenariosAll[idx] = state.editorDraft;
      saveScenarios();
      state.editorDirty = false;
      toast("Saved");
      renderScenarioList();
      renderEditorLeft();
      renderTopEditorControls();
    }
  }
  function discardEditorChanges(){
    if(!state.editorDraft) return;
    if(!confirm("Discard changes?")) return;
    const original = getScenarioById(state.editorScenarioId);
    if(!original) return;
    state.editorDraft = JSON.parse(JSON.stringify(original));
    state.editorDirty = false;
    state.selectedCells.clear();
    state.palette = {};
    for(const a of state.editorDraft.actions){
      state.palette[a] = (a === "Fold") ? 100 : 0;
    }
    toast("Discarded");
    renderEditorLeft();
    renderEditorMain();
    renderTopEditorControls();
  }

  function renderTopEditorControls(){
    if(state.mode !== "editor" || !state.editorDraft){
      topEditorControls.style.display = "none";
      topEditorControls.innerHTML = "";
      return;
    }
    topEditorControls.style.display = "flex";
    topEditorControls.innerHTML = `
      <span class="badge ${state.editorDirty ? "warn" : "good"}">${state.editorDirty ? "Unsaved" : "Saved"}</span>
      <button class="btn small primary" id="topSave" ${state.editorDirty ? "" : "disabled"}>Save (Ctrl/⌘+S)</button>
      <button class="btn small" id="topDiscard" ${state.editorDirty ? "" : "disabled"}>Discard</button>
    `;
    topEditorControls.querySelector("#topSave").addEventListener("click", saveEditorChanges);
    topEditorControls.querySelector("#topDiscard").addEventListener("click", discardEditorChanges);
  }

  function renderEditorLeft(){
    leftTitle.textContent = "Editor";
    const scen = state.editorDraft;
    if(!scen){
      leftBody.innerHTML = `<div class="muted">Pick a scenario to edit.</div>`;
      return;
    }

    const actions = scen.actions;
    const parts = getActionCounts(actions);

    leftBody.innerHTML = `
      <div class="row" style="justify-content:space-between;">
        <span class="badge ${state.editorDirty ? "warn":""}">${state.editorDirty ? "Unsaved" : "Saved"}</span>
        <span class="tag">Format: <b>${escapeHTML(scen.format || state.format)}</b></span>
      </div>

      <div class="hr"></div>

      <div class="col">
        <div style="font-weight:950;">Scenario name</div>
        <input class="textInput" id="scenNameInput" value="${escapeHTML(scen.name)}" />
      </div>

      <div class="hr"></div>

      <div class="actionManage">
        <div style="font-weight:950;">Actions</div>
        <div class="actionPills" id="actionPills"></div>
        <div class="row" style="gap:8px;">
          <button class="btn small" id="addCall" ${parts.hasCall ? "disabled":""}>+ Call</button>
          <button class="btn small" id="addRaise" ${parts.nRaises>=6 ? "disabled":""}>+ Raise</button>
          <button class="btn small" id="addJam" ${parts.hasJam ? "disabled":""}>+ Jam</button>
        </div>
      </div>

      <div class="hr"></div>

      <div class="col">
        <div style="font-weight:950;">Palette</div>
      </div>

      <div class="hr"></div>

      <div class="col" id="paletteArea"></div>

      <div class="hr"></div>

      <div class="row">
        <button class="btn primary" id="btnSave" ${state.editorDirty ? "" : "disabled"}>Save (Ctrl/⌘+S)</button>
        <button class="btn" id="btnDiscard" ${state.editorDirty ? "" : "disabled"}>Discard</button>
        <button class="btn" id="btnExportDraft">Export JSON</button>
      </div>
    `;

    const nameInput = leftBody.querySelector("#scenNameInput");
    nameInput.addEventListener("input", () => {
      state.editorDraft.name = nameInput.value;
      state.editorDirty = true;
      renderTopEditorControls();
      renderEditorLeft();
      renderScenarioList();
    });

    // action pills with remove
    const pills = leftBody.querySelector("#actionPills");
    const order = aggressionOrder(actions); // show aggressive first
    pills.innerHTML = order.map(a => {
      const removable = (a !== "Fold");
      return `
        <span class="actionChip">
          <span class="sw" style="background:${actionColor(a)}"></span>
          <span>${escapeHTML(a)}</span>
          ${removable ? `<span class="pillX" data-rm="${escapeHTML(a)}">×</span>` : ``}
        </span>
      `;
    }).join("");

    pills.querySelectorAll("[data-rm]").forEach(x => {
      x.addEventListener("click", () => {
        const rm = x.getAttribute("data-rm");
        removeActionFromEditor(rm);
      });
    });

    leftBody.querySelector("#addCall").addEventListener("click", () => addActionToEditor("Call"));
    leftBody.querySelector("#addRaise").addEventListener("click", () => addActionToEditor("Raise"));
    leftBody.querySelector("#addJam").addEventListener("click", () => addActionToEditor("Jam"));

    // palette sliders (with numeric input + quick % buttons)
    const pal = leftBody.querySelector("#paletteArea");
    pal.innerHTML = actions.map(a => {
      const v = Math.round((state.palette[a] ?? (a==="Fold"?100:0)));
      return `
        <div class="col" style="gap:8px; padding:10px; border:1px solid rgba(255,255,255,.06); border-radius:14px; background:rgba(0,0,0,.10);">
          <div class="row" style="justify-content:space-between; gap:10px; flex-wrap:nowrap;">
            <span class="tag" style="min-width:120px;"><span class="sw" style="background:${actionColor(a)}"></span>${escapeHTML(a)}</span>
            <div class="row" style="gap:8px; align-items:center; flex:1; min-width:0; flex-wrap:nowrap;">
              <input type="range" min="0" max="100" step="1" value="${v}" data-act="${escapeHTML(a)}" style="flex:1; min-width:120px;" />
              <input type="number" min="0" max="100" step="1" value="${v}" data-num="${escapeHTML(a)}" class="pctNum" />
            </div>
          </div>
          <div class="row pctBtns" style="gap:6px; flex-wrap:nowrap;">
            <button class="btn small" data-setpct="${escapeHTML(a)}" data-pct="0">0%</button>
            <button class="btn small" data-setpct="${escapeHTML(a)}" data-pct="20">20%</button>
            <button class="btn small" data-setpct="${escapeHTML(a)}" data-pct="40">40%</button>
            <button class="btn small" data-setpct="${escapeHTML(a)}" data-pct="60">60%</button>
            <button class="btn small" data-setpct="${escapeHTML(a)}" data-pct="80">80%</button>
            <button class="btn small" data-setpct="${escapeHTML(a)}" data-pct="100">100%</button>
          </div>
        </div>
      `;
    }).join("");

    
    // Palette interop: keep DOM stable so sliders can be dragged smoothly
    function clamp01(v){
      v = Number(v);
      if(!Number.isFinite(v)) v = 0;
      return Math.max(0, Math.min(100, v));
    }

    function setActionExactPct(act, target){
      target = clamp01(target);

      // Pure button
      if(target >= 100){
        for(const x of actions) state.palette[x] = 0;
        state.palette[act] = 100;
        return;
      }

      // Scale everyone else to fill remaining
      const others = actions.filter(x => x !== act);
      const rem = 100 - target;

      // Current other totals
      let sumOthers = 0;
      for(const x of others){
        sumOthers += Math.max(0, Number(state.palette[x] ?? 0));
      }

      if(sumOthers <= 0){
        // If no other weights, give remainder to Fold if possible, else the first other
        for(const x of others) state.palette[x] = 0;
        const recip = (act !== "Fold" && others.includes("Fold")) ? "Fold" : (others[0] || act);
        if(recip !== act) state.palette[recip] = rem;
      }else{
        const scale = rem / sumOthers;
        for(const x of others){
          state.palette[x] = Math.max(0, Number(state.palette[x] ?? 0)) * scale;
        }
      }

      state.palette[act] = target;

      // Final tidy normalize for rounding drift
      state.palette = normalizePctMap(state.palette, actions);
    }

    function syncPaletteUI(){
      pal.querySelectorAll('input[type="range"][data-act]').forEach(r => {
        const a = r.getAttribute("data-act");
        const v = Math.round(Number(state.palette[a] ?? 0));
        if(String(r.value) !== String(v)) r.value = v;
      });
      pal.querySelectorAll('input[type="number"][data-num]').forEach(n => {
        const a = n.getAttribute("data-num");
        const v = Math.round(Number(state.palette[a] ?? 0));
        if(String(n.value) !== String(v)) n.value = v;
      });
    }

    function markDirtyAndRefresh(){
      state.editorDirty = true;
      renderTopEditorControls();
      syncPaletteUI();
      renderEditorMain();
    }

    pal.querySelectorAll('input[type="range"][data-act]').forEach(r => {
      r.addEventListener("input", () => {
        const a = r.getAttribute("data-act");
        setActionExactPct(a, r.value);
        markDirtyAndRefresh();
      });
    });

    pal.querySelectorAll('input[type="number"][data-num]').forEach(n => {
      n.addEventListener("input", () => {
        const a = n.getAttribute("data-num");
        setActionExactPct(a, n.value);
        markDirtyAndRefresh();
      });
    });

    pal.querySelectorAll('button[data-setpct]').forEach(b => {
      b.addEventListener("click", () => {
        const a = b.getAttribute("data-setpct");
        const pct = Number(b.getAttribute("data-pct") || "0");
        setActionExactPct(a, pct);
        markDirtyAndRefresh();
      });
    });

leftBody.querySelector("#btnSave").addEventListener("click", saveEditorChanges);
    leftBody.querySelector("#btnDiscard").addEventListener("click", discardEditorChanges);
    leftBody.querySelector("#btnExportDraft").addEventListener("click", () => {
      if(!state.editorDraft) return;
      downloadJSON(state.editorDraft, safeName(state.editorDraft.name) + ".json");
    });
  }

  function addActionToEditor(kind){
    const s = state.editorDraft;
    if(!s) return;
    const parts = getActionCounts(s.actions);

    let hasCall = parts.hasCall;
    let hasJam  = parts.hasJam;
    let nRaises = parts.nRaises;

    if(kind === "Call") hasCall = true;
    else if(kind === "Jam") hasJam = true;
    else if(kind === "Raise") nRaises = Math.min(6, nRaises + 1);

    rebuildScenarioActions(s, hasCall, nRaises, hasJam);

    // palette: ensure all keys exist
    const newPal = {};
    for(const a of s.actions) newPal[a] = (a === "Fold") ? (state.palette[a] ?? 100) : (state.palette[a] ?? 0);
    state.palette = normalizePctMap(newPal, s.actions);

    state.editorDirty = true;
    renderTopEditorControls();
    renderEditorLeft();
    renderEditorMain();
  }

  function removeActionFromEditor(action){
    const s = state.editorDraft;
    if(!s) return;
    if(action === "Fold") return;

    const parts = getActionCounts(s.actions);

    let hasCall = parts.hasCall;
    let hasJam  = parts.hasJam;
    let nRaises = parts.nRaises;

    if(action === "Call") hasCall = false;
    else if(action === "Jam") hasJam = false;
    else if(String(action).toLowerCase().startsWith("raise")){
      // remove one raise size: drop count by 1
      nRaises = Math.max(0, nRaises - 1);
    }

    rebuildScenarioActions(s, hasCall, nRaises, hasJam);

    const newPal = {};
    for(const a of s.actions) newPal[a] = (a === "Fold") ? 100 : 0;
    state.palette = newPal;

    state.editorDirty = true;
    renderTopEditorControls();
    renderEditorLeft();
    renderEditorMain();
  }

  function renderEditorMain(){
    mainTitle.textContent = "Editor";
    const scen = state.editorDraft;
    scenarioTag.textContent = scen ? scen.name : "—";
    if(!scen){
      mainBody.innerHTML = `<div class="muted">Pick a scenario to edit.</div>`;
      window.onkeydown = null;
      return;
    }

    mainBody.innerHTML = `
      ${renderSelectionStripHTML({compact:false})}
      <div class="hr"></div>
      <div class="panel" style="background:rgba(15,22,33,.55); border:1px solid var(--line); border-radius:14px; padding:12px; height: calc(100vh - 56px - 14px - 14px - 70px - 120px);">
        <div class="row" style="justify-content:space-between; align-items:center;">
          <div class="row">
            <span class="tag">Cells: <b>${state.selectedCells.size}</b></span>
            <button class="btn small" id="btnClearSel">Clear</button>
          </div>
        </div>
        <div class="hr"></div>
        <div style="height: calc(100% - 52px);">
          ${renderGridHTML(scen, null, {allowClickSelect:true, scenarioId: scen.id, small:false})}
        </div>
      </div>
    `;

    const grid = document.getElementById("grid");

    const paintCell = (hand) => {
      const s = state.editorDraft;
      if(!s) return;
      const actions = s.actions;
      const pct = normalizePctMap(state.palette, actions);
      s.grid[hand] = pct;
      state.editorDirty = true;
      state.selectedCells.add(hand);

      const el = grid.querySelector(`[data-hand="${hand}"]`);
      if(el){
        el.style.backgroundImage = buildGradientForCell(pct, actions);
      }
      setSelection(s.id, hand);
      renderTopEditorControls();
    };

    const clearSelection = () => {
      state.selectedCells.clear();
      toast("Cleared");
      renderEditorMain();
    };

    byId("btnClearSel").addEventListener("click", clearSelection);

    state.paintDown = false;
    grid.addEventListener("mousedown", (e) => {
      const cell = e.target.closest(".cell[data-hand]");
      if(!cell) return;
      state.paintDown = true;
      paintCell(cell.getAttribute("data-hand"));
      e.preventDefault();
    });
    grid.addEventListener("mousemove", (e) => {
      if(!state.paintDown) return;
      const cell = e.target.closest(".cell[data-hand]");
      if(!cell) return;
      paintCell(cell.getAttribute("data-hand"));
    });
    window.addEventListener("mouseup", () => state.paintDown = false);

    window.onkeydown = (ev) => {
      if(state.mode !== "editor") return;
      const isSave = (ev.key.toLowerCase() === "s") && (ev.ctrlKey || ev.metaKey);
      if(isSave){
        ev.preventDefault();
        saveEditorChanges();
      }
      if(ev.key === "Escape"){
        clearSelection();
      }
    };

    setTimeout(() => fitAllGrids(), 0);
  }

  /* =========================
     Trainer
  ========================= */
  function computeSessionAvgPct(attempts){
    if(!attempts.length) return 0;
    return Math.round(attempts.reduce((a,x)=>a + (x.pts||0), 0) / attempts.length);
  }

  function buildSessionQueueFromPool(pool){
    state.sessionQueue = [];
    for(let i=0;i<state.sessionLen;i++){
      const scen = pool[Math.floor(Math.random()*pool.length)];
      const hand = randomHandLabel();
      state.sessionQueue.push({scenarioId: scen.id, hand});
    }
    state.sessionActive = true;
    state.currentIdx = 0;
    state.attempts = [];
    state.reveal = false;
    state.lastTierClass = "";
    state.lastUserAction = null;
    state.trainerResults = null;

    setCurrentHandFromQueue();
  }

  function startSession(){
    const visible = getVisibleScenarios();
    const selectedSet = getSelectedSet();
    const pool = visible.filter(s => selectedSet.has(s.id));
    if(pool.length === 0){
      toast("Select at least one scenario");
      return;
    }
    state.lastSessionConfig = {
      format: state.format,
      selectedIds: [...selectedSet],
      sessionLen: state.sessionLen,
      mode: "multi",
    };
    buildSessionQueueFromPool(pool);
    syncModeUI();
    toast("Started");
  }

  function startSessionForScenarioId(id){
    const sc = getScenarioById(id);
    if(!sc || sc.format !== state.format){
      toast("Scenario not available");
      return;
    }
    state.lastSessionConfig = {
      format: state.format,
      selectedIds: [id],
      sessionLen: state.sessionLen,
      mode: "single",
      scenarioId: id,
    };
    buildSessionQueueFromPool([sc]);
    syncModeUI();
    toast("Started");
  }

  function stopSession(){
    if(!state.sessionActive) return;
    endSessionAndShowResults("Stopped");
  }

  function setCurrentHandFromQueue(){
    const item = state.sessionQueue[state.currentIdx];
    if(!item){
      endSessionAndShowResults("Completed");
      return;
    }
    const scenario = getScenarioById(item.scenarioId);
    if(!scenario){
      state.currentIdx++;
      return setCurrentHandFromQueue();
    }
    const pctMap = scenario.grid[item.hand] || {};
    const pick = pickSolverAction(pctMap, scenario.actions);

    state.currentHand = {
      scenario,
      hand: item.hand,
      rng: pick.rng,
      solverChoice: pick.choice,
      normalized: pick.normalized,
      cards: handToTwoCards(item.hand),
    };
    state.reveal = false;
    state.lastTierClass = "";
    state.lastUserAction = null;

    // selection defaults to this scenario (hand unset until click)
    state.selection = { scenarioId: scenario.id, hand: null };

    renderTrainerMain(); // update immediately
  }

  function handleUserAction(action){
    const ch = state.currentHand;
    if(!ch || state.reveal) return;

    const scenario = ch.scenario;
    const actual = scenario.actions.find(a => String(a).toLowerCase() === String(action).toLowerCase());
    if(!actual){
      toast("Action not available");
      return;
    }

    const {tier, pts} = scoreAttempt(actual, ch.solverChoice, ch.normalized, scenario.actions);
    state.attempts.push({
      ts: nowISO(),
      format: state.format,
      scenarioId: scenario.id,
      scenarioName: scenario.name,
      hand: ch.hand,
      rng: ch.rng,
      solverChoice: ch.solverChoice,
      userAction: actual,
      tier,
      pts,
    });

    state.lastUserAction = actual;
    state.reveal = true;
    state.lastTierClass = tier === "best" ? "good" : (tier==="correct" ? "warn" : "bad");

    state.lastSessionScore = computeSessionAvgPct(state.attempts);
    renderTrainerMain();
  }

  function nextOrResults(){
    // called after reveal
    const isLast = (state.currentIdx >= state.sessionQueue.length - 1);
    if(isLast){
      endSessionAndShowResults("Completed");
      return;
    }
    state.currentIdx++;
    setCurrentHandFromQueue();
  }

  function endSessionAndShowResults(status){
    const attempts = state.attempts;
    const avg = computeSessionAvgPct(attempts);
    const best = attempts.filter(a=>a.tier==="best").length;
    const corr = attempts.filter(a=>a.tier==="correct").length;
    const wrong = attempts.filter(a=>a.tier==="wrong").length;

    const report = {
      id: crypto.randomUUID(),
      status,
      createdAt: nowISO(),
      format: state.format,
      sessionLen: state.sessionQueue.length,
      selectedScenarioCount: getSelectedSet().size,
      avgScore: avg,
      breakdown: {best, correct:corr, wrong},
      attempts: attempts.slice(0, 800),
    };
    addReport(report);

    state.sessionActive = false;
    state.sessionQueue = [];
    state.currentIdx = 0;
    state.currentHand = null;
    state.reveal = false;

    state.trainerResults = {
      reportId: report.id,
      reportObj: report,
      config: state.lastSessionConfig,
    };

    syncModeUI();
  }

  function renderTrainerLeft(){
    leftTitle.textContent = "Trainer";
    leftBody.innerHTML = `
      <div class="row" style="justify-content:space-between;">
        <div class="pill"><span class="muted">Length</span> <b>${state.sessionLen}</b></div>
        <input id="sessLen" type="range" min="5" max="60" step="1" value="${state.sessionLen}" />
      </div>

      <div class="hr"></div>

      <div class="row" style="justify-content:space-between;">
        <div class="toggle">
          <input type="checkbox" id="toggleGrid" ${state.showGridAfterAnswer ? "checked":""} />
          <label for="toggleGrid" class="tiny muted">Show grid after answer</label>
        </div>
      </div>

      <div class="hr"></div>

      <div class="row">
        <button class="btn primary" id="btnStart">${state.sessionActive ? "Restart" : "Start"}</button>
        <button class="btn" id="btnStop" ${state.sessionActive ? "" : "disabled"}>Stop</button>
      </div>
    `;

    leftBody.querySelector("#sessLen").addEventListener("input", (e)=>{
      state.sessionLen = Number(e.target.value);
      saveUI();
      renderTrainerLeft();
    });
    leftBody.querySelector("#toggleGrid").addEventListener("change", (e)=>{
      state.showGridAfterAnswer = !!e.target.checked;
      saveUI();
      renderTrainerMain();
    });

    leftBody.querySelector("#btnStart").addEventListener("click", startSession);
    leftBody.querySelector("#btnStop").addEventListener("click", stopSession);
  }

  function renderTrainerResultsScreen(){
    mainTitle.textContent = "Trainer";
    const res = state.trainerResults;
    const report = res?.reportObj;
    scenarioTag.textContent = report ? `${report.status} · ${report.sessionLen} hands` : "—";

    if(!report){
      mainBody.innerHTML = `<div class="muted">No results.</div>`;
      return;
    }

    const pct = report.avgScore;
    const tier = scoreTier(pct);
    const phrase = pickRandom(tier.phrases);

    mainBody.innerHTML = `
      <div class="bigResult">
        <div class="pct">${pct}%</div>
        <div class="title">${escapeHTML(phrase)}</div>
        <div class="subtitle">${escapeHTML(tier.note)}</div>
      </div>

      <div class="hr"></div>

      <div class="row" style="justify-content:space-between;">
        <div class="row">
          <span class="tag">Best <b>${report.breakdown.best}</b></span>
          <span class="tag">Correct <b>${report.breakdown.correct}</b></span>
          <span class="tag">Wrong <b>${report.breakdown.wrong}</b></span>
        </div>
        <div class="row">
          <button class="btn primary" id="btnRestart">Restart <span class="mono">(Enter)</span></button>
          <button class="btn" id="btnViewReport">View details</button>
        </div>
      </div>

      <div class="hr"></div>

      <div class="split2">
        <div class="stickyBox">
          <div style="font-weight:950;">Mistakes</div>
          <div class="tiny muted" style="margin-top:6px;">Click a row to preview.</div>
          <div class="hr"></div>
          ${renderMistakesTable(report)}
        </div>
        <div class="stickyBox" id="mistakePreview">
          ${renderMistakePreview(report, null)}
        </div>
      </div>
    `;

    // interactions
    byId("btnRestart").addEventListener("click", () => restartLastDrill());
    byId("btnViewReport").addEventListener("click", () => {
      state.mode = "reports";
      state.reportSelectedId = report.id;
      state.reportSelectedAttemptIdx = null;
      syncModeUI();
    });

    // click mistake rows
    mainBody.querySelectorAll("[data-mrow]").forEach(row => {
      row.addEventListener("click", () => {
        const idx = Number(row.getAttribute("data-mrow"));
        const preview = byId("mistakePreview");
        preview.innerHTML = renderMistakePreview(report, idx);
        wireMiniPreviewClicks(preview, report, idx);
      });
    });

    wireMiniPreviewClicks(mainBody, report, null);

    // hotkey: Enter restarts
    window.onkeydown = (ev) => {
      if(ev.key === "Enter"){
        ev.preventDefault();
        restartLastDrill();
      }
    };

    setTimeout(() => fitAllGrids(), 0);
  }

  function restartLastDrill(){
    const cfg = state.lastSessionConfig;
    if(!cfg){
      toast("No previous drill");
      return;
    }
    // ensure format matches
    if(cfg.format !== state.format){
      state.format = cfg.format;
      saveUI();
    }
    // select same scenarios
    setSelectedSet(new Set(cfg.selectedIds || []));
    if(cfg.mode === "single" && cfg.scenarioId){
      setBrowseScenarioId(cfg.scenarioId);
      startSessionForScenarioId(cfg.scenarioId);
    }else{
      startSession();
    }
  }

  function scoreTier(pct){
    if(pct >= 100){
      return {
        note: "100%",
        phrases: ["Perfect","Flawless victory","Jedi Master","White Magic Hero"]
      };
    }
    if(pct >= 95){
      return {
        note: "95–99%",
        phrases: ["Strong","Badass","Near Perfect","The Force is strong with this one."]
      };
    }
    if(pct >= 90){
      return { note: "90–94%", phrases: ["You are doin it!"] };
    }
    if(pct >= 80){
      return { note: "80–89%", phrases: ["Not bad kid"] };
    }
    if(pct >= 70){
      return { note: "70–79%", phrases: ["OK, keep pushing though"] };
    }
    if(pct >= 60){
      return { note: "60–69%", phrases: ["Could do with work on this spot"] };
    }
    if(pct >= 40){
      return { note: "40–59%", phrases: ["Do the drill more times, you'll get it"] };
    }
    return { note: "0–39%", phrases: ["Sorry man do this drill 10 times and learn what is going wrong!"] };
  }
  function pickRandom(arr){
    if(!arr || !arr.length) return "";
    return arr[Math.floor(Math.random()*arr.length)];
  }

  function renderMistakesTable(report){
    const wrongs = (report.attempts||[]).map((a,i)=>({a,i})).filter(x => x.a.tier === "wrong");
    if(!wrongs.length){
      return `<div class="muted">No mistakes.</div>`;
    }
    const rows = wrongs.slice(0, 30).map(x => {
      const a = x.a;
      return `
        <div class="row rowClick trBad" data-mrow="${x.i}"
             style="padding:10px;border-radius:12px;border:1px solid rgba(255,255,255,.06); margin-bottom:8px;">
          <span class="tag mono">${escapeHTML(a.hand)}</span>
          <span class="tag">${escapeHTML(a.userAction)}</span>
          <span class="tag" style="border-color:rgba(255,204,102,.25); color:var(--warn);">→ ${escapeHTML(a.solverChoice)}</span>
          <span class="tag" style="max-width:320px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${escapeHTML(a.scenarioName)}</span>
        </div>
      `;
    }).join("");
    return rows;
  }

  function renderMistakePreview(report, idx){
    if(idx == null){
      return `<div class="muted">Select a mistake to preview.</div>`;
    }
    const a = report.attempts[idx];
    if(!a) return `<div class="muted">Not found.</div>`;
    const scen = getScenarioById(a.scenarioId);
    if(!scen){
      return `
        <div>
          <div class="row">
            <span class="tag mono">${escapeHTML(a.hand)}</span>
            <span class="tag">${escapeHTML(a.userAction)}</span>
            <span class="tag" style="border-color:rgba(255,204,102,.25); color:var(--warn);">→ ${escapeHTML(a.solverChoice)}</span>
          </div>
          <div class="hr"></div>
          <div class="muted">Scenario not found (maybe deleted).</div>
        </div>
      `;
    }
    // set selection for percent strip
    state.selection = { scenarioId: scen.id, hand: a.hand };
    return `
      <div>
        <div class="row" style="justify-content:space-between;">
          <div class="row">
            <span class="tag mono">${escapeHTML(a.hand)}</span>
            <span class="tag">${escapeHTML(a.userAction)}</span>
            <span class="tag" style="border-color:rgba(255,204,102,.25); color:var(--warn);">→ ${escapeHTML(a.solverChoice)}</span>
          </div>
          <span class="tag">${escapeHTML(scen.name)}</span>
        </div>
        <div class="hr"></div>
        ${renderSelectionStripHTML({compact:false})}
        <div class="hr"></div>
        <div style="height:320px;">
          ${renderGridHTML(scen, a.hand, {allowClickSelect:true, scenarioId: scen.id, small:true})}
        </div>
      </div>
    `;
  }

  function wireMiniPreviewClicks(containerEl, report, idx){
    // Click mini-grid cells in preview to update selection strip
    containerEl.querySelectorAll(".cell[data-clickselect='1']").forEach(cell => {
      cell.addEventListener("click", () => {
        const sid = cell.getAttribute("data-sid");
        const hand = cell.getAttribute("data-hand");
        setSelection(sid, hand);
      });
    });
  }

  function renderTrainerMain(){
    mainTitle.textContent = "Trainer";

    // If results screen active
    if(state.mode === "trainer" && state.trainerResults){
      renderTrainerResultsScreen();
      return;
    }

    const browseId = getBrowseScenarioId();
    const browseScen = browseId ? getScenarioById(browseId) : null;
    scenarioTag.textContent = browseScen ? browseScen.name : "—";

    // Browse mode (session inactive)
    if(!state.sessionActive){
      if(!browseScen){
        mainBody.innerHTML = `<div class="muted">No scenarios in ${state.format}. Import JSON (Library) or create one.</div>`;
        window.onkeydown = null;
        return;
      }

      // Selection strip + grid browse
      state.selection.scenarioId = browseScen.id;

      mainBody.innerHTML = `
        ${renderSelectionStripHTML({compact:false})}
        <div class="hr"></div>
        <div class="panel" style="background:rgba(15,22,33,.55); border:1px solid var(--line); border-radius:14px; padding:12px; height: calc(100vh - 56px - 14px - 14px - 70px - 120px);">
          <div style="height:100%;">
            ${renderGridHTML(browseScen, null, {allowClickSelect:true, scenarioId:browseScen.id, small:false})}
          </div>
        </div>
      `;

      window.onkeydown = null;
      setTimeout(() => fitAllGrids(), 0);
      return;
    }

    const ch = state.currentHand;
    if(!ch){
      mainBody.innerHTML = `<div class="muted">Loading...</div>`;
      return;
    }

    const {scenario, hand, rng, solverChoice, normalized, cards} = ch;
    scenarioTag.textContent = scenario.name;

    const hasCall = scenario.actions.some(a=>String(a).toLowerCase()==="call");
    const raiseActions = sortRaisesSmallToLarge(scenario.actions.filter(a=>String(a).toLowerCase().startsWith("raise")));
    const hasJam = scenario.actions.some(a=>String(a).toLowerCase()==="jam");

    const numbered = numberedAggroActions(scenario);
    const keyForAction = (act) => {
      const idx = numbered.findIndex(x => String(x).toLowerCase() === String(act).toLowerCase());
      return idx >= 0 ? String(idx+1) : "";
    };

    const scoreSoFar = computeSessionAvgPct(state.attempts);
    const scoreLabel = state.attempts.length ? `${scoreSoFar}%` : "—";

    const isLast = (state.currentIdx >= state.sessionQueue.length - 1);
    const nextLabel = isLast ? `See results` : `Next hand`;
    const nextHotkey = "Enter";

    // Right grid panel: only show after reveal and toggle is on
    const showGrid = (state.reveal && state.showGridAfterAnswer);

    // set selection owner
    state.selection.scenarioId = scenario.id;

    mainBody.innerHTML = `
      <div class="row" style="justify-content:space-between; align-items:stretch; gap:14px;">
        <div class="col" style="gap:10px; flex:1; min-width:520px;">
          <div class="scenarioName">${escapeHTML(scenario.name)}</div>

          <div class="cards">
            ${renderCardHTML(cards[0])}
            ${renderCardHTML(cards[1])}
            <div class="pill"><span class="muted">Combo</span> <b class="mono">${hand}</b></div>
            <div class="pill"><span class="muted">Hand</span> <b class="mono">#${state.currentIdx+1}/${state.sessionQueue.length}</b></div>
          </div>

          <div class="rngBanner">RNG: ${rng}</div>

          <div class="scoreBanner">
            <div>
              <div class="sub">Session score</div>
              <div class="big">${scoreLabel}</div>
            </div>
            <div class="sub">${state.attempts.length} / ${state.sessionQueue.length} played</div>
          </div>

          <div class="panel" style="background:rgba(15,22,33,.55); border:1px solid var(--line); border-radius:14px; padding:12px;">
            <div class="actionBar" id="actionBar">
              <button class="actBtn actFold" data-act="Fold"><span>Fold</span><span class="k">X</span></button>
              ${hasCall ? `<button class="actBtn actCall" data-act="Call"><span>Call</span><span class="k">C</span></button>` : ``}

              ${raiseActions.map(a => `
                <button class="actBtn actRaise" data-act="${escapeHTML(a)}">
                  <span>${escapeHTML(a)}</span>
                  <span class="k">${keyForAction(a)}</span>
                </button>
              `).join("")}

              ${hasJam ? `
                <button class="actBtn actJam" data-act="Jam">
                  <span>All-in</span>
                  <span class="k">${keyForAction("Jam")}${keyForAction("Jam") ? " / " : ""}Z</span>
                </button>
              ` : ``}
            </div>

            <div class="hr"></div>

            <div id="revealBlock" style="display:${state.reveal ? "block":"none"};">
              <div class="row" style="justify-content:space-between; align-items:center;">
                <div class="row">
                  <span class="tag" style="border-color:rgba(255,204,102,.25); color:var(--warn);">RNG: <b class="mono">${escapeHTML(solverChoice)}</b></span>
                </div>
                <div class="row">
                  <span class="badge ${state.lastTierClass || ""}" id="lastScoreBadge" style="font-size:16px;padding:10px 14px;font-weight:900;border-radius:999px;">—</span>
                  <button class="btn primary" id="btnNext">${nextLabel} <span class="mono">(${nextHotkey})</span></button>
                </div>
              </div>
              <div class="hr"></div>
              <div class="row">
                ${scenario.actions.map(a => {
                  const v = Math.round((normalized[a]||0)*10)/10;
                  return `<span class="tag"><span class="sw" style="background:${actionColor(a)}"></span>${escapeHTML(a)}: <b>${v}%</b></span>`;
                }).join("")}
              </div>
            </div>
          </div>
        </div>

        <div class="panel" style="flex:0 0 680px; max-width:45vw; min-width:560px; background:rgba(15,22,33,.55); border:1px solid var(--line); border-radius:14px; padding:12px; height: calc(100vh - 56px - 14px - 14px - 96px);">
          <div class="row" style="justify-content:space-between; align-items:center;">
            <div class="row">
              <span class="tag">Selected</span>
              <span class="tag mono">${escapeHTML(state.selection.hand || "—")}</span>
            </div>
            <div class="row">
              ${state.selection.hand ? `<span class="tag">${escapeHTML(state.selection.hand)}</span>` : ``}
            </div>
          </div>
          <div class="hr"></div>
          <div style="height: calc(100% - 52px);">
            ${showGrid
              ? `
                ${renderSelectionStripHTML({compact:false})}
                <div class="hr"></div>
                <div style="height: calc(100% - 120px);">
                  ${renderGridHTML(scenario, hand, {allowClickSelect:true, scenarioId: scenario.id, small:false})}
                </div>
              `
              : `<div class="muted">${state.reveal ? "Grid hidden." : "Answer to reveal."}</div>`
            }
          </div>
        </div>
      </div>
    `;

    const actionBar = document.getElementById("actionBar");
    const buttons = Array.from(actionBar.querySelectorAll("[data-act]"));
    buttons.forEach(btn => {
      btn.addEventListener("click", () => handleUserAction(btn.getAttribute("data-act")));
      btn.disabled = state.reveal; // lock after answer
    });

    // highlight user / solver on reveal
    if(state.reveal){
      const user = state.lastUserAction;
      const solver = solverChoice;

      const userBtn = buttons.find(b => String(b.getAttribute("data-act")).toLowerCase() === String(user).toLowerCase());
      const solverBtn = buttons.find(b => String(b.getAttribute("data-act")).toLowerCase() === String(solver).toLowerCase());
      if(userBtn){
        userBtn.classList.add(state.lastTierClass === "bad" ? "hlWrong" : "hlCorrect");
      }
      if(solverBtn){
        solverBtn.classList.add("hlSolver");
      }

      const badge = byId("lastScoreBadge");
      if(badge){
        const tier = state.attempts[state.attempts.length-1]?.tier;
        badge.className = `badge ${state.lastTierClass}`;
        badge.textContent = tier === "best" ? `BEST · 100` : (tier==="correct" ? `CORRECT · 70` : `WRONG · 0`);
      }

      byId("btnNext").addEventListener("click", nextOrResults);
    }

    // hotkeys
    window.onkeydown = (ev) => {
      if(!state.sessionActive) return;

      if(state.reveal && ev.key === "Enter"){
        ev.preventDefault();
        return nextOrResults();
      }
      if(state.reveal) return;

      const k = ev.key.toLowerCase();
      if(k === "x") return handleUserAction("Fold");
      if(k === "c" && hasCall) return handleUserAction("Call");
      if(k === "z" && hasJam) return handleUserAction("Jam");

      if(/^[1-9]$/.test(k)){
        const n = parseInt(k,10);
        const pick = numbered[n-1];
        if(pick) return handleUserAction(pick);
      }
    };

    // bind grid click to selection if shown
    if(showGrid){
      mainBody.querySelectorAll(".cell[data-clickselect='1']").forEach(cell => {
        cell.addEventListener("click", () => {
          const sid = cell.getAttribute("data-sid");
          const h = cell.getAttribute("data-hand");
          setSelection(sid, h);
        });
      });
    }

    setTimeout(() => fitAllGrids(), 0);
  }

  /* =========================
     Library
  ========================= */
  function renderLibraryLeft(){
    leftTitle.textContent = "Library";
    leftBody.innerHTML = `
      <div class="row" style="justify-content:space-between;">
        <div class="pill"><span class="muted">Scenarios</span> <b>${getVisibleScenarios().length}</b></div>
        <div class="row">
          <button class="btn small" id="btnNewScenario">New</button>
          <button class="btn small" id="btnExport">Export</button>
          <button class="btn small danger" id="btnDelete">Delete</button>
        </div>
      </div>
    `;
    leftBody.querySelector("#btnNewScenario").addEventListener("click", () => createNewScenario(true));
    leftBody.querySelector("#btnExport").addEventListener("click", exportSelectedScenarios);
    leftBody.querySelector("#btnDelete").addEventListener("click", deleteSelectedScenarios);
  }

  function renderLibraryMain(){
    mainTitle.textContent = "Library";
    const browseId = getBrowseScenarioId();
    const browseScen = browseId ? getScenarioById(browseId) : null;
    scenarioTag.textContent = browseScen ? browseScen.name : "—";

    if(!browseScen){
      mainBody.innerHTML = `<div class="muted">No scenarios in ${state.format}.</div>`;
      window.onkeydown = null;
      return;
    }
    state.selection.scenarioId = browseScen.id;

    mainBody.innerHTML = `
      ${renderSelectionStripHTML({compact:false})}
      <div class="hr"></div>
      <div class="panel" style="background:rgba(15,22,33,.55); border:1px solid var(--line); border-radius:14px; padding:12px; height: calc(100vh - 56px - 14px - 14px - 70px - 120px);">
        <div class="row" style="justify-content:space-between;">
          <div class="row">
            <button class="btn small" id="btnEditBrowse">Edit</button>
          </div>
        </div>
        <div class="hr"></div>
        <div style="height: calc(100% - 52px);">
          ${renderGridHTML(browseScen, null, {allowClickSelect:true, scenarioId:browseScen.id, small:false})}
        </div>
      </div>
    `;

    byId("btnEditBrowse").addEventListener("click", () => openEditor(browseScen.id));

    // selection clicks
    mainBody.querySelectorAll(".cell[data-clickselect='1']").forEach(cell => {
      cell.addEventListener("click", () => {
        const sid = cell.getAttribute("data-sid");
        const h = cell.getAttribute("data-hand");
        setSelection(sid, h);
      });
    });

    window.onkeydown = null;
    setTimeout(() => fitAllGrids(), 0);
  }

  /* =========================
     Reports (full session data + sorting + mini grid)
  ========================= */
  function renderReportsLeft(){
    leftTitle.textContent = "Reports";
    const reps = loadReports().filter(r => (r.format || "MTT") === state.format);

    leftBody.innerHTML = `
      <div class="row" style="justify-content:space-between;">
        <div class="pill"><span class="muted">Sessions</span> <b>${reps.length}</b></div>
        <button class="btn small danger" id="btnClearReports">Clear</button>
      </div>
      <div class="hr"></div>
      <div class="reportList" id="reportList"></div>
    `;

    const list = leftBody.querySelector("#reportList");
    list.innerHTML = reps.slice(0, 60).map(r => {
      const active = (state.reportSelectedId === r.id);
      const cls = `reportCard ${active ? "active":""}`;
      return `
        <div class="${cls}" data-rid="${escapeHTML(r.id)}">
          <div class="row" style="justify-content:space-between;">
            <b>${escapeHTML(r.status || "")}</b>
            <span class="badge ${r.avgScore >= 80 ? "good" : (r.avgScore >= 60 ? "warn" : "bad")}">${r.avgScore}%</span>
          </div>
          <div class="tiny muted">${new Date(r.createdAt).toLocaleString()} · ${r.sessionLen} hands</div>
          <div class="tiny muted">Best ${r.breakdown?.best||0} · Correct ${r.breakdown?.correct||0} · Wrong ${r.breakdown?.wrong||0}</div>
        </div>
      `;
    }).join("") || `<div class="muted">No sessions yet.</div>`;

    list.querySelectorAll("[data-rid]").forEach(card => {
      card.addEventListener("click", () => {
        state.reportSelectedId = card.getAttribute("data-rid");
        state.reportSelectedAttemptIdx = null;
        renderReportsLeft();
        renderReportsMain();
      });
    });

    leftBody.querySelector("#btnClearReports").addEventListener("click", () => {
      if(!confirm(`Delete all ${state.format} reports from this browser?`)) return;
      const all = loadReports();
      const keep = all.filter(r => (r.format || "MTT") !== state.format);
      saveReports(keep);
      state.reportSelectedId = null;
      toast("Cleared");
      renderReportsLeft();
      renderReportsMain();
    });
  }

  function renderReportsMain(){
    mainTitle.textContent = "Reports";
    scenarioTag.textContent = `Format: ${state.format}`;

    const reps = loadReports().filter(r => (r.format || "MTT") === state.format);
    const selected = state.reportSelectedId ? reps.find(r => r.id === state.reportSelectedId) : reps[0];
    if(selected && !state.reportSelectedId) state.reportSelectedId = selected.id;

    if(!selected){
      mainBody.innerHTML = `<div class="muted">No reports.</div>`;
      window.onkeydown = null;
      return;
    }

    const attempts = selected.attempts || [];
    const avg = selected.avgScore || 0;

    mainBody.innerHTML = `
      <div class="row" style="justify-content:space-between; align-items:center;">
        <div class="row">
          <span class="tag">${escapeHTML(selected.status)}</span>
          <span class="tag">${new Date(selected.createdAt).toLocaleString()}</span>
          <span class="tag">Hands: <b>${selected.sessionLen}</b></span>
          <span class="tag">Score: <b>${avg}%</b></span>
        </div>
        <div class="row">
          <select id="repFilter" class="btn small">
            <option value="all">All</option>
            <option value="wrong">Wrong</option>
            <option value="correct">Correct</option>
            <option value="best">Best</option>
          </select>
          <select id="repSort" class="btn small">
            <option value="errors">Errors first</option>
            <option value="time">Time</option>
            <option value="pts">Score</option>
            <option value="scenario">Scenario</option>
          </select>
        </div>
      </div>

      <div class="hr"></div>

      <div class="split2">
        <div class="stickyBox">
          ${renderAttemptsTable(selected)}
        </div>
        <div class="stickyBox" id="attemptPreview">
          ${renderAttemptPreview(selected, state.reportSelectedAttemptIdx)}
        </div>
      </div>
    `;

    const f = byId("repFilter");
    const s = byId("repSort");
    f.value = state.reportFilter;
    s.value = state.reportSort;

    f.addEventListener("change", () => {
      state.reportFilter = f.value;
      state.reportSelectedAttemptIdx = null;
      renderReportsMain();
    });
    s.addEventListener("change", () => {
      state.reportSort = s.value;
      state.reportSelectedAttemptIdx = null;
      renderReportsMain();
    });

    mainBody.querySelectorAll("[data-arow]").forEach(row => {
      row.addEventListener("click", () => {
        const idx = Number(row.getAttribute("data-arow"));
        state.reportSelectedAttemptIdx = idx;
        renderReportsMain();
      });
    });

    // wire preview mini grid clicks
    wirePreviewSelectionClicks(mainBody);

    window.onkeydown = null;
    setTimeout(() => fitAllGrids(), 0);
  }

  function filteredSortedAttempts(report){
    const list = (report.attempts || []).map((a,i)=>({a,i}));

    const filt = state.reportFilter;
    let out = list;
    if(filt === "wrong") out = out.filter(x => x.a.tier === "wrong");
    if(filt === "correct") out = out.filter(x => x.a.tier === "correct");
    if(filt === "best") out = out.filter(x => x.a.tier === "best");

    const sort = state.reportSort;
    out = out.slice();
    if(sort === "time"){
      out.sort((x,y) => (x.i - y.i));
    }else if(sort === "pts"){
      out.sort((x,y) => (y.a.pts - x.a.pts) || (x.i - y.i));
    }else if(sort === "scenario"){
      out.sort((x,y) => String(x.a.scenarioName).localeCompare(String(y.a.scenarioName)) || (x.i - y.i));
    }else{
      // errors first
      const rank = (t) => t === "wrong" ? 0 : (t === "correct" ? 1 : 2);
      out.sort((x,y) => (rank(x.a.tier) - rank(y.a.tier)) || (x.i - y.i));
    }
    return out;
  }

  function renderAttemptsTable(report){
    const rows = filteredSortedAttempts(report);
    if(!rows.length) return `<div class="muted">No rows.</div>`;

    const head = `
      <table class="table">
        <thead>
          <tr>
            <th style="width:56px;">#</th>
            <th>Scenario</th>
            <th style="width:90px;">Hand</th>
            <th style="width:140px;">You</th>
            <th style="width:160px;">RNG</th>
            <th style="width:90px;">Pts</th>
          </tr>
        </thead>
        <tbody>
    `;
    const body = rows.map(x => {
      const a = x.a;
      const cls = a.tier === "wrong" ? "trBad" : (a.tier === "correct" ? "trGood" : "trWarn");
      const pts = a.pts ?? (a.tier==="best"?100:(a.tier==="correct"?70:0));
      const you = escapeHTML(a.userAction);
      const rng = escapeHTML(a.solverChoice);
      return `
        <tr class="${cls} rowClick" data-arow="${x.i}">
          <td class="mono">${x.i+1}</td>
          <td>${escapeHTML(a.scenarioName)}</td>
          <td class="mono">${escapeHTML(a.hand)}</td>
          <td>${you}</td>
          <td style="color:var(--warn);">${rng}</td>
          <td class="mono">${pts}</td>
        </tr>
      `;
    }).join("");

    return head + body + `</tbody></table>`;
  }

  function renderAttemptPreview(report, idx){
    if(idx == null){
      return `<div class="muted">Select a row.</div>`;
    }
    const a = report.attempts[idx];
    if(!a) return `<div class="muted">Not found.</div>`;
    const scen = getScenarioById(a.scenarioId);

    if(!scen){
      return `
        <div>
          <div class="row">
            <span class="tag mono">${escapeHTML(a.hand)}</span>
            <span class="tag">${escapeHTML(a.userAction)}</span>
            <span class="tag" style="color:var(--warn); border-color:rgba(255,204,102,.25)">→ ${escapeHTML(a.solverChoice)}</span>
          </div>
          <div class="hr"></div>
          <div class="muted">Scenario not found (maybe deleted).</div>
        </div>
      `;
    }

    state.selection = { scenarioId: scen.id, hand: a.hand };

    return `
      <div>
        <div class="row" style="justify-content:space-between;">
          <div class="row">
            <span class="tag mono">${escapeHTML(a.hand)}</span>
            <span class="tag">${escapeHTML(a.userAction)}</span>
            <span class="tag" style="color:var(--warn); border-color:rgba(255,204,102,.25)">→ ${escapeHTML(a.solverChoice)}</span>
          </div>
          <span class="tag">${escapeHTML(scen.name)}</span>
        </div>

        <div class="hr"></div>

        ${renderSelectionStripHTML({compact:false})}

        <div class="hr"></div>

        <div style="height:320px;">
          ${renderGridHTML(scen, a.hand, {allowClickSelect:true, scenarioId: scen.id, small:true})}
        </div>
      </div>
    `;
  }

  function wirePreviewSelectionClicks(container){
    container.querySelectorAll(".cell[data-clickselect='1']").forEach(cell => {
      cell.addEventListener("click", () => {
        const sid = cell.getAttribute("data-sid");
        const hand = cell.getAttribute("data-hand");
        setSelection(sid, hand);
      });
    });
  }

  /* =========================
     Mode switching & format switching
  ========================= */
  function syncModeUI(){
    modeSeg.querySelectorAll("button").forEach(b => {
      b.classList.toggle("active", b.getAttribute("data-mode") === state.mode);
    });
    formatSeg.querySelectorAll("button").forEach(b => {
      b.classList.toggle("active", b.getAttribute("data-format") === state.format);
    });
    formatTag.textContent = `Format: ${state.format}`;

    renderScenarioHeaderActions();
    renderScenarioList();
    renderTopEditorControls();
    renderLeft();
    renderMain();
    saveUI();
    setTimeout(() => fitAllGrids(), 0);
  }

  modeSeg.addEventListener("click", (e) => {
    const btn = e.target.closest("button[data-mode]");
    if(!btn) return;

    if(state.mode === "editor" && state.editorDirty){
      const ok = confirm("You have unsaved changes. Leave without saving?");
      if(!ok) return;
    }

    state.mode = btn.getAttribute("data-mode");

    // leaving trainer results if switching away
    if(state.mode !== "trainer") state.trainerResults = null;

    syncModeUI();
  });

  formatSeg.addEventListener("click", (e) => {
    const btn = e.target.closest("button[data-format]");
    if(!btn) return;

    if(state.mode === "editor" && state.editorDirty){
      const ok = confirm("You have unsaved changes. Switch without saving?");
      if(!ok) return;
    }

    const nextFmt = btn.getAttribute("data-format");
    if(nextFmt === state.format) return;

    // stop session and clear results on format switch
    state.sessionActive = false;
    state.sessionQueue = [];
    state.currentHand = null;
    state.reveal = false;
    state.attempts = [];
    state.trainerResults = null;

    state.format = nextFmt;

    // ensure browse exists
    if(!getBrowseScenarioId()){
      const first = getVisibleScenarios()[0];
      setBrowseScenarioId(first ? first.id : null);
    }
    closeEditor();

    const b = getBrowseScenarioId();
    state.selection = {scenarioId: b, hand: null};

    syncModeUI();
  });

  window.addEventListener("beforeunload", (e) => {
    if(state.editorDirty){
      e.preventDefault();
      e.returnValue = "";
    }
  });

  /* =========================
     Left / Main routing
  ========================= */
  function renderLeft(){
    if(state.mode === "trainer") renderTrainerLeft();
    else if(state.mode === "editor") renderEditorLeft();
    else if(state.mode === "library") renderLibraryLeft();
    else if(state.mode === "reports") renderReportsLeft();
  }
  function renderMain(){
    if(state.mode === "trainer") renderTrainerMain();
    else if(state.mode === "editor") renderEditorMain();
    else if(state.mode === "library") renderLibraryMain();
    else if(state.mode === "reports") renderReportsMain();
  }

  /* =========================
     Global: save in editor hotkey
  ========================= */
  document.addEventListener("keydown", (ev) => {
    const isSave = (ev.key.toLowerCase() === "s") && (ev.ctrlKey || ev.metaKey);
    if(isSave && state.mode === "editor"){
      ev.preventDefault();
      saveEditorChanges();
    }
  });

  /* =========================
     Resizable left pane
  ========================= */
  const divider = document.getElementById("dragDivider");
  let dragging = false;
  divider.addEventListener("mousedown", () => dragging = true);
  window.addEventListener("mouseup", () => dragging = false);
  window.addEventListener("mousemove", (e) => {
    if(!dragging) return;
    const x = e.clientX;
    const min = 280, max = 560;
    const w = Math.min(max, Math.max(min, x));
    document.getElementById("leftPane").style.width = w + "px";
    saveUI();
    setTimeout(() => fitAllGrids(), 0);
  });

  /* =========================
     Reset site data
  ========================= */
  byId("btnResetAll").addEventListener("click", () => {
    if(!confirm("Reset all site data? (This browser only)")) return;
    localStorage.removeItem(LS_SCEN);
    localStorage.removeItem(LS_REP);
    localStorage.removeItem(LS_UI);

    // older keys too
    localStorage.removeItem("pokerTrainerScenarios_v2");
    localStorage.removeItem("pokerTrainerScenarios_v1");
    localStorage.removeItem("pokerTrainerReports_v2");
    localStorage.removeItem("pokerTrainerReports_v1");
    localStorage.removeItem("pokerTrainerUI_v2");
    localStorage.removeItem("pokerTrainerUI_v1");

    state.scenariosAll = [];
    state.selectedIdsByFormat = { MTT: new Set(), Cash: new Set() };
    state.browseScenarioIdByFormat = { MTT: null, Cash: null };
    state.selection = { scenarioId: null, hand: null };
    state.sessionActive = false;
    state.trainerResults = null;

    saveScenarios();
    toast("Reset");
    syncModeUI();
  });

  /* =========================
     Autoplay from URL (new tab play)
  ========================= */
  function applyAutoplayFromURL(){
    const u = new URL(window.location.href);
    const fmt = u.searchParams.get("format");
    const playId = u.searchParams.get("play");
    const mode = u.searchParams.get("mode");
    if(fmt === "MTT" || fmt === "Cash") state.format = fmt
